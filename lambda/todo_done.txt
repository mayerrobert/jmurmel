Erledigt:
==========================================

welches ergebnis liefert lambda mit einer liste als body?
-> sollte ergebnis der letzten form sein

Klasse Builtin statt UnaryOperator<Pair> einfuehren

eq vergleicht identitaet, was macht Lisp? https://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp
-> checken ob das passt, z.b. (eq (cons (quote 1) (quote 2)) (cons (quote 1) (quote 2))) ist nicht identisch aber gleich (?)
-> GNU CLISP v2.49+ liefert NIL

Eine JUnit funktion, die liest alle lisp files aus einem verzeichnis und führt sie aus.
erwartetes Ergebnis bzw. fehlermeldung steht in der datei in einem kommentar drin, z.B.
; result:(1 . 2)
oder
; error-prefix: SyntaxError in line 12:
und ggf.
; output: Hallo Welt

Lambda -> LambdaJ

Vielleicht in printObj umlenken:
(quote t) -> "t"
null -> "nil"

beim scannen zeile und spalte mitzaehlen und in fehlermeldung einbauen

apply fuer lambdas, siehe apply.lisp

verschiedene konstruktoren fuer Pair und ueberladene cons brauchts wahrscheinlich nicht, cons(Object,Object) muesste reichen

builtin write-line
-> common lisp hat das, parameter muss aber ein string sein

Datentyp double, (nicht int) unterstuetzen

eq fuer number korrigieren
-> oder eq lassen und = einfuehren, achtung beim vergleichen von double!
-> vielleicht = mit optionalem drittem double parameter fuzz fuer die genauigkeit

+ - * / %, factorial beispiel

car, cdr umstellen dass sie Object uebernehmen
-> dann gibts einen cast in car/cdr statt 1000 casts ueberall

vielleicht "Object car(Object)" und "Pair pcar(Object)"?
-> Eruebrigt sich ggf. durch Umstellen von car(Pair) nach car(Object) 

die parameterchecks ignorieren zuviele argumente

numberp, ggf. atom korrigieren
symbol? vs atom vs numberp

<, >, usw checken ob Double#compareTo Vorteile bzgl. NaN und +- 0.0 hat, derzeit passiert Unboxing

tests fuer atom, consp, listp, symbolp, numberp

test fuer eval nil und eval t, ggf. symbol t einfuehren

tests und fehlertests fuer number und operatoren

numberp() ggf. teilweise durch atom() ersetzen, dann koennen externe Builtins ihre eigenen Datentypen
in car reinstecken, der Interpreter sieht und verarbeitet nur Object

errortests fuer lambda/ builtin mit zuviel/ zuwenig parametern aufrufen

errortests fuer fehler wie erster parameter fuer lambda ist keine symbolliste

Sollen die interpret...() Methoden einen String oder ein Objekt zurueckgeben?
Vielleicht Object zurueck, und ConsCell bekommt eine toString() Methode basierend auf printObj?

Scanner/Parser in eine Klasse rausziehen, je ein Objekt ProgramParser und InputDataParser,
die Lisp Funktion read verwendet den InputDataParser.
Symboltabelle zu geeigneten Zeitpunkten auf null setzen, wahrscheinlich im Konstruktor der ScannerParserKlasse

if(!strcmp(token, "\'")) return cons(quote, cons(readobj(), nil));

isParen und isQuote nach isSyntax zusammenziehen



Tail recursion erkennen: es wird eine Funktion aufgerufen, die im environment 1 hoeher ist (?)
oder wenigstens loop einbauen
-> einfacher ists alle tailcalls zu optimieren

eval hat einige endrekursive aufrufe. koennte man eliminieren.
vielleicht noch einen zweiten levelzaehler einfuehren, dann kann man den level fuer eval und (kleinere) rekursionstiefe anzeigen

eigentlich passiert die rekursion ja in eval:
evlis, evcon & co inline expandieren, und das letzte listenelement nicht mit rekursion aufrufen sondern
manuell tail recursion elimination machen.

PROBLEM: function calls haben ein geaendertes environment extenv
-> einen stack aus extenvs aufbauen: ein int "stackarray" in dem merkt man sich, wieviele elemente vorne
drangepickt wurden und nach verarbeiten des calls entfernt werden müssen 

dann werden nicht nur tail rekursionen wegoptimiert, sondern alle tail calls. es ruft zwar die eine Lisp funktion
eine andere auf, aber in wirklichkeit laeuft nur der code der einzigen Java-methode eval. 



eval, evlis, evcon vielleicht in haendischem CPS?!?
-> eruebrigt sich durch TCO

Erkennung von zirkulaeren Listen koennte man in printObj einbauen
-> aber ohne set gibts derzeit eh keine zirkulaeren Listen ?!?)
-> contains self aber schon

printObj auf loop umbauen, "sich selbst enthalten erkennen", vgl collection.toString()

"t" aus/ einschaltbar machen: flag "HAVE_TRUE"
-> falls true  -> t in der symbol table und _expTrue = t
-> falls false -> t nicht in der symbol table und _expTrue = (quote t)

Numbersupport mit flags ausschalten?
Optional BigDecimal statt Double?

fnull, fcons usw brauchen keine members zu sein, koennten lokale variablen in environment() sein
-> vorher environment() aufteilen?

der Double Support ist eigentlich nur mittels Builtins umgesetzt
-> in ein eigenes ExtEnv verpacken, damit kann mans optional machen,
   oder alternativ/ zusaetzlich z.B. BigDecimal unterstuetzen
-> UND im Lexer gibts Support fuer Double

--help

Datentyp Strings unterstuetzen
-> laenger als SYMBOL_MAX=32

Strings und Characters braucht eigentlich nur der Scanner, Parser (readObj) und Builtin Funktionen (inkl printObj!!!) kennen.
Strings, Chars und Symbols sind alles Atoms, aber nur Symbols sind in der Symboltable

Parser refactoren:
LispParser bekommt statt InputStream einen IntProducer:
fuer InputStream in:
    () -> in::read
oder fuer StringReader s:
    () ->  s::read

readObj umbauen dass (a . b) eingelesen werden kann?

Builtins sollten ggf. expression mitbekommen fuer ausgabe von fehlermeldungen

printObj sollte symbols mit syntax als |xxx| printen. Was syntax characters sind, weiss nur der Parser
-> printObj als Methode von Parser, naechsten punkt umsetzen!

Builtins sollten ggf. parser (symboltabelle) und ggf. environment mitbekommen, dann koennten sie static sein,
waer ggf. besser fuer custom builtins
-> builtins mit env koennten late binding machen
-> builtins muessen printObj des parsers verwenden
-> environment() koennte static sein

!!!!!!! Alles falsch: Syntax characters bestimmt der ObjectWriter.
Builtins sollten Symboltabelle, ObjectReader in, ObjectWriter out, ggf. Tracer, ggf. Environment bekommen

write sollte ObjectWriter.printObj() verwenden,
zum Tracen weiterhin das statische printObj verwenden
-> LispParser (eigentlich ObjectWriter, s.u.) bekommt methode printObj, bisherige statische Methode printObj in traceObj umbenennen oder printSExpression 
-> write schreibt im gewuenschten Format, Errormessages sind im Format S-expression
-> Syntax characters von S-expressions als static Konstante von LambdaJ rausziehen,
   dann kanns Lispparser und das statische printObj verwenden



getrennter Reader fuer read
-> Object interpret(Supplier lispSource, Supplier lispStdin, Consumer lispStdout, Supplier<ConsCell> customEnvironment)
-> oder LambdaJ in Builder Pattern umbauen:

interface ObjectReader { Object readObj(); }
interface SymbolTable { String intern(); }
interface Parser extends ObjectReader, SymbolTable

interface ObjectWriter { String printObj(Object o, boolean headOfList, boolean eol); }
class LispParser implements Parser, ObjectWriter

interface Tracer { void println(String); }

FFI: eine special form "extlabels". funktioniert aehnlich wie labels,
aber statt funktionsdefinitionen gibt man einen Klassennamen an (und vielleicht ein zusaetzliches optionales namenspraefix,
damit man im falle von gleichnamige methoden in zwei klassen "namespaces" zum trennen verwenden kann), und
von dieser klasse werden alle public methoden mit der Signatur UnaryOperator<Pair> ins Environment gesteckt.
Oder statt reflection: "extlabels" bekommt den Namen einer statischen methode die liefert eine Map Funktionsname->UnaryOperator<Pair>

Oder: LambdaJ bekommt eine Methode void registerBuiltin(String funcName, Builtin javaFunc), die pickt eine neue
Funktion ans Environment vorne dran.
Oder: zus. Parameter ConsCell extEnv, damit kann man eine Liste mit zusaetzlichen Builtins mitgeben



primitive string-format-localized: erster parameter ist locale, z.B.
(format-string-localized "en-US" "%g" 1)

evlis/ evcond sollten auch was tracen. stackanzeige erhoehen, evallevel nicht
einrueckung basiert auf javastackzaehler, anzahl sterndaln evallevel - javastackzaehler

apply erlaubt nur 2 argumente, sollte aber 2+ akzeptieren (und gegen parameterliste checken?)
siehe apply3.lisp
laut http://www.n-a-n-o.com/lisp/cmucl-tutorials/LISP-tutorial-20.html:
(apply #'+ 3 4 '(3 4))
Apply is just like funcall, except that its final argument should be a list; the elements of that list are treated
as if they were additional arguments to a funcall.
-> apply ist komplett hinueber

(write " ") schreibt " " inkusive der double quotes
-> vielleicht write-string und write-line

Escapig von " ", ', \ ...
SExpWriter sollte so schreiben wie SExpReader liest, d.h. mit escaping
ConsCell.toString() sollte nicht escapen
gelesen wird ein Symbol he\(lo, geschrieben wird |he(lo|

Wenn eine Funktion labels oder cond enthaelt, werden tailcalls effektiv nicht wegoptimiert, weil evlabels bzw. evcond
auf den Java stack kommt. "if" ist in eval inline drin, deswegen funktioniert TCO trotz "if".

environment umsortieren

eval braucht keine elsif Kette sein: in jedem if gibts return oder continue

applyPrimitive (2x) in eval in ein try/catch wrappen, im catch:
throw new LambdaJError(e.getMessage + expError(exp))
-> damit sieht man in welcher expression z.B. argumente nicht passen

evlabels inlinen und TCO

performance: benchmarken
warum ist das environment eine liste von listen statt eine liste von cons cells

am ende wird stack und nesting getraced falls TRC_EVAL.
-> TRC_STATS statt TRC_EVAL, zusaetzlich walltime, cpu und anzahl ConsCells tracen.

in dbeval die groesse des environment ausgeben. wahrscheinlich waechst das bei rekursion. 

statt dbgEval -> if (trace >= TRC_EVAL) dbgEval
und die if clause aus dbgEval weg

ggf mit :init altes environment vergessen

im main loop: parsen und checken, ob obj.toString = :w oder = :q ist, so koennte man befehle für den REPL ausserhalb Lisp einbauen

lexikalische closures

lexical closures muessten gehen, indem man das env mit dem lambda mitspeichert und beim aufruf des lambda 
nicht das aktuelle env extended sondern das abgespeicherte
-> umsetzen, indem "lambda" nicht ein lambda ins environment steckt sondern "closure" 
   (oder doch ein lambda und die liste enthaelt nicht nur ("lambda" args body) 
   sondern ("lambda" args body closure), mit nullcheck entscheiden, 
   ob lambda oder closure ausgefuehrt wird. und eval() erweitern, dass closure wie lambda verarbeitet wird, 
   aber statt aktuellem env die closure mit args erweitert
-> mit befehlszeilen parameter --dyn umstellen

labels gehen mit lex clos nicht: im closure sind die labels nicht drin

trace auf final int trace umstellen und im Konstruktor belegen

pfx() und sfx() zusammenziehen, werden immer gemeinsam aufgerufen

' ist wsl falsch: sollte alles rekursiv quoten, derzeit machts nur ein einziges (quote...
-> eher ist apply falsch

der code von apply und functioncall ist fast identisch:
-> makeArgs umbauen, dass kein eval gemacht wird
-> apply macht die args mit eval, functioncall mit evlis
-> mit einigen weiteren umbauten kann functioncall nach apply springen
---> oder beide setzen ein neues 

"enter an expression, enter :h for command help or :q to exit"

defun einbauen, weil define alleine ist muehsam
oder doch defun als macro und macros unterstuetzen?
(defmacro defun (sym params body) (define sym (lambda params body)))

statt Xmal boolean HAVE_xxx
-> ein final int features das im Konstruktor von LambdaJ belegt wird
   static final int HAVE_XXX = 1 << 1,2,3,4...
   methoden boolean haveXXX()
   -> den wert fuer features muss man vorher mit | zusammenbasteln
      zur laufzeit sollten die haveXXX methoden (fast) wegoptimiert werden, wenn features final ist

Bespiel Parser liest serialisierte Objekte, intern ist String.intern()

checken ob die string funktionen geeignet ein/ausgeblendet werden

interpreter bekommt eine methode init()
interpret() überladen das kein neuer parser uebergeben wird. damit kann man immer wieder interpret() aufrufen und defines bleiben bestehen

die sSymbol.get() gschichte ist total overengineered, besser das lazy loading ganz weglassen (ausser vielleicht bei exptrue lassen)

ConsCell hat 4 byte platz wg alignment. man koennte ein int mit typ machen statt LambdaJString und instanceof.
CONS=0 PRIM = 1 LAMBDA=2 CLOSURE=3 ATOM=10 SYMBOL=10 STRING=11 CHAR=12 DOUBLE=12
isAtom() { return typ >= ATOM }, dann koennte custom code seine eigenen typen erfinden.
solange die neuen typnummern >= ATOM sind, sieht der interpreter alles als atom
-> geht doch nicht so: das flag wird nicht bei ConsCell gebraucht, sondern bei den values, die als Object car oder cdr gespeichert sind
-> fuer closure genutzt


primitives format und format-locale: erstes bzw. zwei erste args sind strings, schreiben nach lispStdout

        ThreadMXBean threadBean = null;
        long startCpu = 0L;
        long start = 0L;

            threadBean = ManagementFactory.getThreadMXBean();

            if (threadBean != null) {
                startCpu = threadBean.getCurrentThreadCpuTime();
            }
            start = System.nanoTime();

Variable INTERNAL-TIME-UNITS-PER-SECOND
Builtins GET-INTERNAL-REAL-TIME, GET-INTERNAL-RUN-TIME, SLEEP

define/defun

nil in der symboltabelle als Java null ist fishy, weil symbol nil == null false ergibt
deswegen ist auch der hack in eval bei funktionsaufruf notwendig
-> vielleicht reichts doch, im parser umzulegen? aber was ist im modus ohne nil, aber vielleicht ists dann eh kp

bei cond wird nur das erste stmt ausgefuehrt

LambdaJError(String, Object...) + ggf. Stringkonstanten am anfang der Klasse

in setsymtab nur die symbole erstellen, dies laut features geben soll (if have...)

nCells nicht static, statt im Konstruktor in cons und cons3 schreiben

File mit einigen Expressions als sample session herrichten, sample session mit
  java -jar lambdaj.jar < sample-session.lisp > transcript.txt
erzeugen.
-> flag --prompt einbauen, default fuer tty = true, !tty = false
-> eine sample session mit allen sprachmitteln und kommentaren koennte ein ausfuehrbares reference manual sein
-> aber nur, wenn jede eingelesene zeile auch auf den schirm zurueckgeschrieben wird
   -> parameter --echo und --no-echo
   -> echo koennte umgesetzt werden, indem main SExpressionReader ein Lambda uebergibt, das nicht nur liest sondern ggf. alles
      gelesene auch schreibt
   -> --prompt koennte umgesetzt werden, indem main nicht direkt nach stdout schreibt sondern in ein lambda, das schreibt oder nicht
      oder entweder nach --prompt: (s-> System.out.print) oder --no-prompt: (s-> return)

dotted lists werden entweder nicht richtig glesen oder geschrieben
soll:
'(a . b)              ; (A . B)
'(a . (b . (c . d)))  ; (A B C . D)
'(a b c . d)          ; pprint: (A B C . D)
'(a . (b . (c . ()))) ; (A B C)
'(a b c)              ; (A B C)

LambdaJ ist fast ein Subset von CL, Unterschiede zu CL dokumentieren, am besten ein kurzes Manual mit allen Sprachmitteln
und ggf. Unterschieden
oder ein builtin "help": (help) listet alle special forms und builtins nach lispStdout, (help symbol) schreibt eine Beschreibung
zu "symbol" nach stdout

im repl wird zeile/char immer weitergezaehlt

writeln umbauen auf "\n<string> "
-> mit param
--eol=LISP
--eol=C

http://www.lispworks.com/documentation/HyperSpec/Body/f_get_un.htm
get-universal-time <no arguments> => sekunden seit 1.1.1900
get-decoded-time <no arguments> => second, minute, hour, date, month, year, day, daylight-p, zone

progn fuer if und anderes?
-> nach schema lambda und fallthrough. in zip() shortcut einbauen: if paramlist == null && arglist == null return

vielleicht doch ein let? das waer ein lambda, das die uebergebene funktion in ein lambda mit den werten verpackt
  oder eine special form die nur das environment erweitert und dann "env=extenv; continue;"
-> let muss eine fexpr sein, special form oder macro, oder doch nicht? ja, sonst wuerden die variablenlisten ausgefuehrt
-> oder define setzt werte im aktuellen env
-> nur letrec als special form. letrec ist die obermenge von let und let*

letrec so wie labels umbauen, dass allfaellige closures alles andere sehen, nicht nur die vorher deklarierten

let*

named let* und letrec
named let: gibt dem body einen namen, damit er sich rekursiv aufrufen kann. waer leicht moeglich, das in letrec einzubauen (if symbolp(car(arguments)))
(define (number->list n)
  (let loop ((n n)
             (acc '()))
    (if (< n 10)
        (cons n acc)
        (loop (quotient n 10)
              (cons (remainder n 10) acc)))))

muss man bei named let immer alle parameter befuellen?
-> in scheme ja

-> number operatoren auf long erweitern
   div: integer division, rem: rest
   numberp erweitern
   floor, ceil und round

printSEx umbauen, dass es statt stringbuilder einen Consumer<String> uebernimmt, zum schreiben in file

eval wird IMMER mit stack+1/level+1 aufgerufen
-> +1 bei den aufrufen weg, am anfang von eval machen

define und defun sollten ggf das symbol liefern

eval ins environment einhaengen?
-> The main reason for beginners is: you don't need it. https://stackoverflow.com/questions/2571401/why-exactly-is-eval-evil

environment erweitern: statt cons(null, null) -> extenv = append(obj, extenv)

try/ catch für javacode in eval statt in d, weil da kann man in der Fehlermeldung die Expression ausgeben

statt der for (list) schleifen den iterator benutzen, sollte dotted list und circular handeln

der Parser koennte integer auch parsen, ggf. auch char, long, biginteger, bigdecimal mit irgendeinem praefix gekennzeichnet. 
sind alle Number, k.a. ob das beim erweitern der operatoren was bringt
-> in den Operatoren ((Number)x).doubleValue zum Rechnen, ergebnis muss dann ggf. auf den richtigen typ gebracht werden
   / ergibt immer double, bei *+/mod haengt der ergebnistyp von den eingehenden typen ab
-> dann bräuchte man wohl auch typumwandelfunctionen, sonst stellts string-format auf, wenn man nicht mehr weiss was man hat

Long im parser unterstuetzen
-> parser geht, cmdline switches + dok fehlen
statt double number dreht double und long auf/ ab, no long dreht ggf. long ab

topEnv kann ein member sein, nicht immer rumreichen, stack detto, mit bisserl aufwand auch level
-> stack und level bleiben params, das sind eigenschaften der methode eval

http://www.lispworks.com/documentation/HyperSpec/Body/f_dec_un.htm
decode-universal-time universal-time &optional time-zone => second, minute, hour, date, month, year, day, daylight-p, zone

FFI: methoden
Object getValue(String globalSymbol)
Object apply(String func, Object... args)

und/ oder

interface MurmelFunction { Object apply(Object... args); }
MurmelFunction getFunction(String func) {...}
Object         getValue(String globalSymbol)

Java FFI:
JSR-223 (Java scripting API)

https://stackoverflow.com/questions/46611132/how-i-merge-lisp-and-java-or-how-i-run-lisp-code-using-java
Interpreter interpreter = Interpreter.createInstance();
interpreter.eval("(load \"my-lisp-code.lisp\")");

Symbol myFunctionSym =
          defaultPackage.findAccessibleSymbol(
               "MY-FUNCTION");
     Function myFunction =
          myFunctionSym.getSymbolFunction();
Cons list = 
          (Cons) myFunction.execute(
                        Fixnum.getInstance(64),
                        Fixnum.getInstance(64));

trace und features in 2 methoden rausziehen

(cons 'a . 'A) -> (a . a)
-> dokumentiert, kein wirkliches problem, nur kosmetische eher positive auswirkung

buitlin apply-java: erster parameter ist ein string statt symbol, d.h. die expression fuer das erste argument muss einen String liefern,
das ist dann der Name einer Klasse und/ oder statischen Methode. Ggf. auch eine statische Methode,
die ein Function<ConsCell,Object> Javalambda liefert.

Vielleicht operator # fuer Javacalls? # wie in javadoc, oder :: wie in methodenreferenzen (waer cooler, moderner)
-> # hat in CL schon eine Bedeutung, z.B. #\C

(define my-map (:: new java.util.HashMap nil))
(:: "put" "java.util.HashMap" my-map "my key" "my value")
(:: "format" "java.lang.String" nil "%g" 1.0)
erster parameter methodenname, zweiter klassenname, dritter objektreferenz oder nil fuer statische methoden, der rest sind parameter fuer die methode
primitive :: koennte durch eine klasse mit methodencache implementiert werden

oder :: erzeugt ein Primitive-Objekt, das Klasse, und Methode enthaelt und spaeter wie eine normale Lisp Funktion aufgerufen
werden kann (aehnlich wie lambda ein closure erzeugt):
(define make-java-map (:: "new" "java.util.HashMap"))
(define java-put-hash (:: "put" "java.util.HashMap")

(define my-map (make-java-map nil))
(java-put-hash my-map "my key" "my value") ; erstes Argument beim Aufruf von "Java-Methoden" ist immer das Java-Objekt, ggf. nil fuer statische Methoden

symbol vielleicht nicht als String sondern class LambdaJSymbol { char[] symname; }, dafuer LambdaJString weg -> stattdessen java.lang.String
-> murmel muss sonst Java string argumente mit symbol abfuellen und Java return String liefert ein symbol (das es nicht gibt)
-> spart eher speicher

parameterchecks fuer letrec

LambdaJ gibts schon. Ausserdem gibts:
JavaLISP, http://jlambda.com, jlisp, rlisp, ROMALISP
-> umbenamsen:
   Murmel: ich mag das tier, murmeln <->-lispeln, Sprache: Murmel, interpreter: jmurmel
   JUCL: Java Un Common Lisp, uncommon Lisp klingt negativ

Vielleicht doch die Zeilennummer in ConsCell speichern fuer Fehlerausgabe?
vielleicht ein --debug flag, dann allokiert der parser andere ConsCells mit zeilennummern?
und printSEx bekommt einen parameter "lines" damit errorexp objekte mit zeilennummern ausgibt
oder LambdaJError bekommt einen zusaetzlichen parameter errorExp und gibt die errorExp aus mit oder ohne zeilennummern
-> ConsCells mit zeilennummern koennte der parser eigentlich immer erzeugen, code gibts nicht so viel, und die daten
   werden dadurch nicht vergroessert

scanner sollte | fuer symbole koennen
oder keine | schreiben
-> "print-read consistency" (a term given in ANSI CL, 2.3.6, in the context of symbols and packages),
   which refers to the concept of objects being printed in a machine-readable way, so that when the
   printed representation is scanned by the reader, a similar object is produced.

die primitive "list" ist trivial: einfach das argument liefern, das ist die variable "arguments" in eval, und das ist bereits genau
die gewuenschte liste

wenn formale parameter eine dotted list sind, wird auf den letzten parameter eine (moeglicherweise leere) liste mit den restlichen argumenten gebunden
-> variadic function mit zumindest einem parameter, scheme machts so
-> checken was passiert, wenn statt einer parameterliste nur ein symbol steht. das koennte dann eine variadic function sein die 0 oder mehrere args schluckt:
   alle argumente werden in eine (ggf leere) liste verpackt und an das einzige parameter symbol gebunden

define hat varargs, defun nicht


statt intern(new LambdaJSymbol... -> genSym(String...
-> das checkt unique symbols und reserved keywords

reserved words einbauen: vgl. Evolution of Lisp, pp 62 ff
-> NIL may not be used as a function, nor as a variable
-> T may not be used as a variable.

redefinieren der symbole von special forms verbieten? auswirkung hats eh keine.
->
special forms werden nicht im environment gesucht, die verarbeitung ist hardcodiert
die auswirkung davon laesst sich durch folgendes symptom beschreiben:
effektiv sind die symbole von special forms in einem eigenen namespace wo operatoren zuerst gesucht werden
(define eval 1) -> eval
(eval eval) -> 1
(eval 'eval) -> 1
vielleicht zumindest insofern reparieren, dass fuer die keywords symbole angelegt werden, dann gibt define einen fehler
und es gibt keine sonstigen auswirkungen mehr
-> aber let & co lassen das redefinieren trotzdem zu

ueberlegen, was special form und was primitive ist und was in der reserved word liste landet
-> primitives sind symbols im global env, die koennte man in lambda params und let bindings benutzen
   special forms funktionieren nicht als let bindings und muessen in die liste
   sprachelemente wie eq, cons, car, cdr koennte man als primitive umsetzen, oder aus performancegruenden als special form
   -> notwendige special forms plus "wichtige" primitives in die liste plus t und nil

vielleicht doch ein sprachmittel um gezielt dyn od lex closures zu erzeugen
-> vielleicht mit self evaluating symbol dynamic (self evaluating weil dann kann man quote oder nicht, ist egal)

tests fuer dynamic lambda

tests fuer lambda mit mehreren stmts
-> dynamic_lambda.lisp

vielleicht die feature flags nur im repl, sonst file variablen
-> file variablen als kommentare vor anderen syntaxzeichen, gleich im kommentarloop im scanner auswerten, der setzt featureflags
   beim setInput() die featureflags wieder zuruecksetzen
zumindest --lex ausbauen und --dyn -> --X-dyn mit warning (nicht mehr Murmel, auch kein subset)
vielleicht alle sprachflags -X-... und --dyn-> -XX-dyn

dzt gibts let* und letrec
-> let dazu, damit in den binding forms das umschliessende environment inkl globals garantiert sichtbar ist
   braucht man zum macros programmieren
-> was ist letrec*

soll bei named letXX das let-symbol in den bindings sichtbar sein?
-> CL hat kein named let
   scheme hat nur named let, kein named let* letrec, body symbol ist in den binding expressions unbound
    -> rausfinden was die nachteile von named let* und letrec sind
    -> rausfinden was die nachteile von named binding in binding expressions sind 


https://docs.racket-lang.org/reference/let.html
https://groups.csail.mit.edu/mac/ftpdir/scheme-7.4/doc-html/scheme_3.html#SEC31

LET: Lisp, Scheme, Racket   Murmel hats nicht
(let ((symbol form)...) bodyform...) -> object
* form sieht nur umschliessendes environment
* bodyform sieht umschliessendes environment und symbols

(let ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
((lambda (s1 s2 s3) bodyform)
  (eval form1)
  (eval form2)
  (eval form3))


NAMED LET: Scheme, Racket      Murmel hats nicht
(let bodysymbol ((symbol form)...) (bodyform)...) -> object
* symbols muessen unique sein
* form sieht nur umschliessendes environment
* body sieht umschliessendes environment, symbols und bodysymbol


LET*: Scheme, Racket       Murmel hats korrekt und zus NAMED LET*
(let* ((symbol form)...) (bodyform)...) -> object
* the symbols need not be distinct; later bindings shadow earlier bindings.
* form sieht umschliessendes environment und vorangegangene symbols (definiert)
* body sieht umschliessendes environment und symbols

(let* ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 form1))
  (let ((s2 form))
    (let ((s3 form3))
       bodyform)))
->
((lambda (s1)
      ((lambda (s2)
            ((lambda (s3)
                  bodyform)
                (eval form3)))
          (eval form2)))
    (eval form1))


(letrec ((symbol form)...) (bodyform)...) -> object
* form sieht umschliessendes environment und alle symbols (undefiniert)
* body sieht umschliessendes environment und symbols

(letrec ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 *undefined*) (s2 *undefined*) (s3 *undefined*))
  (let ((_x_ (eval form1)) (_y_ (eval form1)) (_z_ (eval form1)))   ; unique identifiers
    (set! s1 _x_)
    (set! s2 _y_)
    (set! s3 _z_)
    bodyform))


Racket letrec == Scheme letrec*
(letrec* ((symbol form)...) (bodyform)...) -> object
* The ids must be distinct according to bound-identifier=?.
* form sieht umschliessendes environment und alle symbols (vorangegangene definiert, eigens und folgende undefiniert)
* body sieht umschliessendes environment und symbols

(letrec* ((s1 form1) (s2 form2) (s3 form3)) bodyform) -> object
->
(let ((s1 *undefined*) (s2 *undefined*) (s3 *undefined*))
  (set! s1 (eval form1))
  (set! s1 (eval form1))
  (set! s3 (eval form1))
  bodyform)


-> am besten:
   named letX bleibt weil let loop
   let dazu
   let* bleibt
   letrec* ist anders als scheme: in scheme sehen die let forms alles als bound aber folgende als undefined


dynamic dokumentieren

Unterscheiden: Symbol gibts nicht vs. hat keinen Wert zugewiesen: not bound vs. undefined
-> besseres wording: bound/not bound, defined/bound but not defined
-> spielt eigentlich bisher nur bei letrec eine Rolle
   special forms boundp und definedp, spezialwert "Object undef" einfuehren und in symbol lookup auswerten

statt reserved=cons(symbol, reserved)
-> reserved(Symbol)

primitives nach haeufigkeit umsortieren

These are your father's parentheses
Elegant weapons
for a more... civilized age.

in readme.md nur einfache beispiele, rest in features.md und verweis auf langref

format und string-format zusammenziehen:
-> format t <string> schreibt auf stdout, return wert ist <string>
-> format nil <string> schreibt NICHT auf stdout, return wert ist <string>
-> format-locale und string-format-locale detto

string-format und format doch zusammenziehen:
(format nil "~A, ~A!" "Hello" "world")   ; => "Hello, world!"    schreibt nix, liefert den string
(format t "~A, ~A!" "Hello" "world")     ; => NIL                schreibt nach stdout und liefert nil

behandlung von nil beschreiben (Lisp <> Scheme)

alles geparste in main merken, und mit :w in eine datei schreiben und/ oder zumindest mit :l auflisten
weitere debug gschichten wie zb :env fuer environment auflisten
-> Scala: https://learnxinyminutes.com/docs/scala/
// REPL sessions can be saved
scala> :save /sites/repl-test.scala


javax.tools.JavaCompiler comp = javax.tools.ToolProvider.getSystemJavaCompiler();
CompilationTask c = comp.getTask(null,null, null, null, null, Collections.singletonList(new JavaSourceFromString(..., "class...");
Boolean success = c.call();

in ein jar reinkompilieren:
void compileWithJSR199() throws IOException {
    String cpath = "C2.jar";
    File clientJarFile = new File(cpath);
    File sourceFileToCompile = new File("C3.java");


    javax.tools.JavaCompiler javac = ToolProvider.getSystemJavaCompiler();
    DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
    StandardJavaFileManager stdFileManager = javac.getStandardFileManager(diagnostics, null, null);

    List<File> files = new ArrayList<>();
    files.add(clientJarFile);

    stdFileManager.setLocation(StandardLocation.CLASS_PATH, files);

    Iterable<? extends JavaFileObject> sourceFiles = stdFileManager.getJavaFileObjects(sourceFileToCompile);

    if (!javac.getTask(null, stdFileManager, diagnostics, null, null, sourceFiles).call()) {
        throw new AssertionError("compilation failed");
    }
}
-> geht so nicht, jar muss man selber zsammpacken

generierte klassen in ein jar zsammpacken: https://stackoverflow.com/questions/1281229/how-to-use-jaroutputstream-to-create-a-jar-file

sind NACH dem let die let variablen wieder weg? sollte so sein -> test schreiben
-> falls nicht: waere durch naechsten punkt erledigt

der interpreter sollte haveNumbers haben, der scanner haveDouble und haveLong
-> enumwert HAVE_NUMBERS zusaetzlich, have methoden geeignet verteilen

closures NICHT dynamisches global env
-> ist doch kein problem, interpretiert gehts, und kompiliert: zur runtime sind die globals eh alle da

subOp auf asDouble umstellen

:java sollte filename aus classname ableiten . -> /

asDouble sollte ggf. eine function dbl() aufrufen statt so viel inline
main von MurmelProgram refaktorn: main(new Test())
compareOp auf interpreter angleichen


script fuer den aufruf
-> default parameter
-> files oeffnen und dann von console lesen

defun kompilieren

statt --compile -> --to-java und --to-jar

:run braucht eigentlich keinen Parameter
-> :r

ArraySlice sollte von ConsCell erben, wg. FFI (funktion gibt ArraySlice zurueck)
ConsCell.car/cdr sollten nicht public sein, nur getter
-> car/cdr aus ConsCell weg, damit Vererbung auf ArraySlice passt
-> vielleicht iwie Sequence in die Hierarchie reinbringen?

CL hat die funktion null, Murmel hat not
-> doch wieder umbenamsen, null ist viel haeufiger sprechend als not

Parser Interface refactoren: aufteilen in FormProducer und Symboltable
-> compiler- und interpreter-methoden koennen entweder einen Parser oder symtab/formproducer uebernehmen
-> gibt aber eh schon ObjectReader und symboltable, muss man nur nutzen

Zeilennummern in die kommentare mit rein. was ist eigentliche das problem mit der zeilennummer des beginns einer form? auch fuer "missing ) started at..."

Anatomy of LISP hat einen reader ohne rekursion

der compiler soll generell '\n' schreiben, derzeit ists eine mischung

LispPrinter soll linesep in strings umsetzen, ggf. waehlbar, falls waehlbar -> dokumentieren

REPL muss teilw. noch linesep umsetzen

compiler varargs geht wsl nicht

erforschen, was der zeichensatz beim lesen und schreiben ist, und dokumentieren, moeglichst Java standard verwenden
-> in System.initializeSystemClass() werden die Properties line.separator, sun.stdout.encoding und sun.stderr.encoding ausgewertet
   -> System.out und err schreiben Strings und chars anhand dieser properties, output muesste also passen
-> gelesen wird von stdin byte fuer byte (bytes werden als int geliefert), bytes werden auf char gecastet, char ist unicode
   -> umstellen dass gelesene bytes in ein byte array gespeichert werden,
      und tokenToString wandelt dieses bytearray anschliessend mittels new String(b, Charset.getDefault())
      Charset.getDefault liefert das Charset aus property file.encoding

SExpReader liest bytes, das funktioniert so nicht mit StringReader(der liefert nicht bytes sondern unicode chars als ints)
-> umstellen auf new ByteArrayInputStream(StandardCharsets.UTF_8, "...")

charset als param fuer den scanner (null ist java default), programmcode sollte immer als utf-8 gelesen werden
-> param "charset" einbauen und bei Parsern auf utf8 setzen (StandardCharsets.UTF_8)
    -> ausser im REPL, weil dort kommt der Programmcode von der Konsole

AnyToUnixEol an diversen Stellen einhaengen, derzeit liest nur repl() richtig

nur im Repl den gleichen Parser fuer program und read verwenden, sonst getrennte mit passender EOL konvertierung und charset

bytes mit charsetdecoder nach strings wandeln, mit CodingErrorAction.REPORT erzeugt unlesbarer input eine exception:
https://www.baeldung.com/java-char-encoding

der compiler erzeugt einen (unicode-) string, der wird in ein file mit Charset.getDefault() geschrieben
-> in ein UTF-8 file schreiben
-> oder: compilexx returned einen string. koennte stattdessen einen writer uebernehmen

JSR223: evalScript will fuer den Code einen bytereader, bekommt von JMurmelScriptEngine aber Reader::read (das liefert nicht UTF-8 bytes)
StringReader::read liefert anscheinend bytes entsprechend file.encoding ?!?
-> es braucht wohl einen zus. SExpressionParser der java.io.Reader liest oder einen ReadSupplier der char liefert
-> ausserdem sollte LispReader fuer JSR233 Programme von einem Reader lesen, nicht bytes als file.encoding interpretieren

der reader zaehlt bytes fuer charpos, umlaute sind 2 bytes, deswegen stimmt charpos bei umlauten nicht
-> eigentlich sollten die ObjectReader alle char liefern, und SExpressionParser.token ist ein char array
-> ggf. zus. Konstruktor, der einen Java.io.Reader uebernimmt

fehlende schliessende klammer wird IMMER mit der letzten zeile gemeldet
-> oeffnende Zeile merken und ausgeben

files von der befehlszeile sind im environment des repl aber nicht in der history
-> man kanns zwar interpretieren, aber nicht kompilieren/ mit :run kompilieren und laufen lassen/ mit :l listen

kompilierte jars spucken das letzte result aus, wenns ungleich null ist
der interpreter (file an der befehlszeile) nur mit --result
-> interpreter sollte sich ohne --result so verhalten wie jars, und mit --result ergebnisse aller toplevel forms ausspucken

die konstanten fuer symbolnamen von murmelprogram nach compiler
-> doch nicht damits ein MurmelJavaProgram.getValue() geben kann

der compiler braucht forward deklarationen, der interpreter nicht

die basisklasse MurmelJavaProgram sollte besser MurmelRuntime heissen
-> im Code und in den Strings umbenamsen
-> doch nicht

das generierte getValue() sollte im default ein neues MurmelProgram.getValue aufrufen, das alle vordefinierten globals und primitives liefert
-> stattdessen enthaelt getValue() ein zweites switch mit builtins

(let ((nil 42)) nil)   sollte eig wg reserved word nicht gehen, geht aber in interpreter und compiler
(let ((t 42)) t)       sollte eig wg reserved word nicht gehen, geht aber im compiler
(let ((cons 42)) cons) geht, sollte das einen fehler wg. reserved geben?

(define t 42)          sollte eig wg reserved word nicht gehen, geht aber im compiler
(define nil 42)        sollte eig wg reserved word nicht gehen, geht aber im interpreter, NPE im compiler

muss der compiler auch reserved words handeln?
-> ja, s.o.

methode eval sollte eigentlich evalquote heissen

MurmelJavaProgram implements MurmelProgram
-> MurmelProgram verwenden
-> MurmelJavaProgram auf private oder Package umstellen geht nicht weil erzeugte Progamme das extenden

trace und untrace zum "debuggen", vgl. https://github.com/norvig/paip-lisp/blob/master/docs/chapter1.md

in eval eine lokale variable result einfuehren, das wird vor dem return zugewiesen, dann kann finally den returnwert tracen

--java liest nicht von stdin
--trace=stats gibt nur stats der ersten exp aus

der reader gibt einen kommentarblock als gesondertes objekt
-> nein, --trace=stats schreibt auch die initialisierung mit "() -> -1"

--jar packt nur MurmelProgram.class, die lambdas MurmelProgram$1.class usw gehen verschuett

bei get-decoded-time fehlt der wochentag: ... jahr wochentag "Daylight saving time flag" timezone
timezone hat das falsche vorzeichen: oestlich von greenwich ists negativ
timezone ist ein double, sollte ein "a rational multiple of 1/3600 between -24 (inclusive) and 24 (inclusive)" sein

--java schreibt 1x compiling..., --jar schreibt 2x compiling...

defun koennte eigentlich Methoden ausspucken statt Member + {...}, funcToJava muss halt den richtigen ausdruck ins environment stecken (und extendfunc verwenden statt extendenv, ggf. auch das "bessere" extendfunc mit parameterliste verwenden)
-> ausser es sollte irgendwann moeglich sein, mit setq defuns neu zuzuweisen
-> (define x (lambda...) koennte ebenfalls eine methode ausspucken, oder weiterhin einen lvalue.
-> spaeter mit setq koennte define aenderbar sein, und defun nicht

apply als tailcall koennte/ sollte auch TCOd werden, let und progn bzgl TCO checken

usage gibt keine --no-XXX aus, nur mit parameter --help-features

in --help und --Xhelp aufteilen

eval im interpreter sollte ggf. auch eine funktion sein
-> geht nicht wg. TCO
    -> ein lambda ins environment reinstecken? eigentlich: ein closure, closure ist topenv
eval im compiler hat nur das global env, im interpreter hats das ganze dyn env
wuerde sich beim umstellen auf funktion angleichen lassen
-> oder eval bekommt einen zweiten optionalen param environment, bei null ists topenv

checken was passiert wenn eval eine kompilierte funktion im environment mitbekommt, oder ein lambda oder primitive returned
eval returned Interpreter-Primitive write:
    JMurmel> (apply (eval 'write) '(1))
    1
    ==> t
    JMurmel> :r
    history NOT run as Java - error:
    java.lang.ClassCastException: com.robertmayer.lambdaj.LambdaJ$$Lambda$7/396180261 cannot be cast to com.robertmayer.lambdaj.LambdaJ$MurmelFunction
            at com.robertmayer.lambdaj.LambdaJ$MurmelJavaProgram.applyHelper(LambdaJ.java:3097)

eval bekommt Compiler-Rt-Funktion:
    JMurmel> (eval '(f v) (list (cons 'f write) (cons 'v 1)))
    1
    ==> t
    JMurmel> :r
    history NOT run as Java - error: LambdaJError: function application: not a primitive or lambda: MurmelProgram$$Lambda$66/1440621772@4d14b6c2
    error occurred in S-expression (f v)
    JMurmel>

Compiler primitives stehen als (MurmelFunction)rt():... im Environment.
-> Optimierung: Wenn funcall ueberladen wird, dass es zus. zu funcall(Object...) ein funcall(MurmelFunction...) gibt,
   muesste dieser overload fuer die compiler primitives verwendet werden, und da faellt "if instanceof MurmelPrimitive" weg.
-> Noch besser: Compiler primitives nicht auf MurmelFunction casten sondern auf neuen MurmelCompilerPrimitive, dann koennt der passende overload
   ohne die thunking schleife gemacht werden.

die rt funktion intern() in MurmelJavaProgram ist anders als intern in CL, siehe https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node110.html
wsl ists zwischen make-symbol und intern angesiedelt
-> ggf. statt _intern -> intern, also nicht in der sprache anbieten

nicht: nach -- kommen files, sondern: nach -- kommen args fuer das programm, die stehen dann in *COMMAND-LINE-ARGUMENT-LIST*, vgl abcl p11

labels reparieren

HAVE_LISPEOL/ haveLispEOL/ commandline parameter weg, stattdessen writeln und lnwrite

tempdir wird nicht geloescht

compiler: doppelte define/ defun erkennen

interpreter: doppelte params bei lambda, let und letrec erkennen und verweigern

body() im interpreter fertigmachen

compiler: gibt ArrayIndexOutOfBoundsException, args werden nicht gegen params gecheckt

interpreter: ((lambda (a) a)) sollte einen fehler geben, gibt aber nil. erst ab 2 params werden die argumente richtig gezaehlt

in kommentaren, doku checken ob FFI an den richtigen stellen verwendet wird, ggf. embedded statt FFI

compiler: defun wieder auf Object = ...; {...} umstellen, sobald assignments moeglich sind

der interpreter und kompilierte programme unterstuetze beide getValue() und getFunction(). irgendwie ein interface drueberziehen

global symbol names muessen unique sein, lokale (noch) nicht -> dokumentieren
lambda parameternamen auch nicht, koennte ein problem sein


JMurmel> ((lambda([])((lambda(x |()| |(| |)|)(+ x |(| 1 |)| |()| |(| |(| |(|)) [] [] [] [])) 0)
-> sollte 1 liefern, klemmt aber und wird nie fertig (keine endlosschleife mit CPU usage)

JMurmel> '||
-> klemmt

JMurmel> '|(|
-> klemmt

JMurmel> '|(|  )
==> nil

JMurmel> '|)|
Error: line 2:0: unexpected ')'

Macros: in ANSI Common Lisp, Paul Graham pp413 steht quasiquote expansion
in https://icem.folkwang-uni.de/~finnendahl/cm_kurse/doc/schintro/schintro_130.html#SEC190 ist defmacro skizziert

http://www.gigamonkeys.com/book/macros-defining-your-own.html
(defmacro when (condition . body) (list 'if condition (cons 'progn body)))

JMurmel> (macroexpand-1 '(when (= 1 2) (write "hello ") (write "world")))
==> (if (= 1 2) (progn (write "hello ") (write "world")))

1e3 wird als symbol gelesen
-> doublePattern stimmt nicht

ByteArrayInputStream aus den tests wegputzen

backquote expansion unterschlaegt nil:
JMurmel> `(if a nil 'a-is-nil)
==> (if a (quote a-is-nil)) ; sollte "(if a nil (quote a-is-nil))" sein

Vgl. sbcl:
* `(if a nil 'a-is-nil)
(IF A
    NIL
    'A-IS-NIL)

grafik im compiler
-> was fehlt noch?

vielleicht round -> fround und round liefert ein integer mit expception bei overflow?
vgl http://www.lispworks.com/documentation/HyperSpec/Body/f_floorc.htm
ebenso round, floor, ceiling usw.

varargs im compiler gehen nicht
JMurmel> (defun f (a b . c) (list a b c))

==> f
JMurmel> (f 1 2)

==> (1 2 nil)
JMurmel> :r
history NOT run as Java - error: _f: not enough arguments
Error occured in line 1:1..1:7: (f 1 2)

integerp, floatp, code-char und char-code im compiler

(writeln nil) sollte nil\n schreiben, schreibt aber nur \n
-> interpreter und compiler

(writeln) gibt im compiler
java.lang.ArrayIndexOutOfBoundsException: 0
        at io.github.jmurmel.LambdaJ$MurmelJavaProgram._writeln(LambdaJ.java:3845)
        at io.github.jmurmel.LambdaJ$MurmelJavaProgram.funcall(LambdaJ.java:3996)

; in einem string ?!?

n-aeres char= und in mlib.lisp:eql nutzen

char-code -> char-int
code-char -> int-char

remove-if-not weg (deprecated in CL siehe http://clhs.lisp.se/Body/f_comple.htm), complement dazu, vgl http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Issues/iss172-writeup.html

vielleicht doch require in core murmel? provide, require, *modules*
-> vielleicht load umbenennen in require mit hardcodiertem provides-handling
   -> aber dann kann man im REPL nicht mehr neu laden
      -> ist :load eine abhilfe?

undefmacro
-> oder (defmacro m) entfernt das macro?

-> und ->> siehe https://github.com/amirgamil/lispy/blob/master/lib/library.lpy
; thread-first
; inserts first form as the first argument (second in list) of the second form, and so forth
(macro -> [terms]
    (do
        (define apply-partials [partials expr]
            (if (nil? partials)
                expr
                (if (symbol? (car partials))
                    (list (car partials) (apply-partials (cdr partials) expr))
                    ; if it's a list with other parameters, insert expr (recursive call) 
                    ; as second parameter into partial (note need to use cons to ensure same list for func args)
                    (cons (caar partials) (cons (apply-partials (cdr partials) expr) (cdar partials)))
                )
            )
        )
        (apply-partials (reverse (cdr terms)) (car terms))
    )
)

; thread-last
; same as -> but inserts first form as last argument (last in list) of second form, and so forth
(macro ->> [terms]
    (do
        (define apply-partials [partials expr]
            (if (nil? partials)
                expr
                (if (symbol? (car partials))
                    (list (car partials) (apply-partials (cdr partials) expr))
                    ; if it's a list with other parameters, insert expr (recursive call) 
                    ; as last form 
                    (cons (caar partials) (append (cdar partials) (apply-partials (cdr partials) expr)))
                )
            )
        )
        (apply-partials (reverse (cdr terms)) (car terms))
    )
)

befehlszeilenoption zum kompilieren und laufen lassen

int-char gibts nicht, nur code-char, char-code und char-int (char-int == char-code)
-> wieder zurückbenamsen
   fehler werfen falls kein character

characters sollten #\a sein, nicht 'a'

vielleicht #+, #- und *features*
multiline comments: #| ... |#

every, some

IEEE 754 sagt -0.0 == 0.0
Java == funktioniert, Double.compare() nicht
-> https://de.wikipedia.org/wiki/Vorzeichenbehaftete_Null#Vergleichsoperatoren

Builtin signum: if instanceof Long (n < 0)?-1:1, für double mit Math.signum

murmel-test automatisch laufen lassen, am ende ggf. fatal

=, <, > usw behandeln NaN nicht richtig:

let loop sollte auch 0 bindings akzeptieren

push & co auf get-setf-expansion umstellen

(funcall (lambda nil)) geht in sbcl, liefert nil
-> ((lambda nil)) sollte in murmel gehen, liefert aber "Error: lambda: expected 2 arguments or more but got only 1" bzw npe im compiler

mlib: length funktion für strings und listen, funktion (char string n) -> nter character von string

samples umsortieren: samples.murmel und samples.murmel-mlib
-> gabriel vielleicht in beiden, in samples.murmel-mlib brauchts weniger anpassungen

named letrec geht nicht im compiler, weils überhaupt nicht implementiert ist -> cce

bei mehreren files an der cmdline nur das ergebnis vom letzten ausgeben

load im compiler

getsym brauchts auch im compiler, z.b. für die funktion get-setf-expansion

atom2java: char und string unicode escapen: nur ascii, satzzeichen  und ziffern direkt ausgeben, rest als \u...

JMurmel> (apply + nil)
==> 0.0
JMurmel> :r
history NOT run as Java - error:
java.lang.NullPointerException
        at io.github.jmurmel.LambdaJ$MurmelJavaProgram.add(LambdaJ.java:4167)
        at io.github.jmurmel.LambdaJ$MurmelJavaProgram.funcall(LambdaJ.java:4277)
        at io.github.jmurmel.LambdaJ$MurmelJavaProgram.applyHelper(LambdaJ.java:4286)
        at MurmelProgram.runbody(MurmelProgram.java:127)

setq, rplaca, rplacd im compiler
-> rplaca, rplacd erledigt
-> setq teilw erledigt (nur eins)
-> setq erledigt

--run soll nil nicht als result printen, :r schon

https://gigamonkeys.com/book/variables.html
Each initialization form is either a list containing a variable name and an initial value form
or--as a shorthand for initializing the variable to NIL--a plain variable name.
The following LET form, for example, binds the three variables x, y, and z with initial values 10, 20, and NIL:
(let ((x 10) (y 20) z)
  ...)

Vielleicht car, cdr, cons, ConsCell in eine Basisklasse LambdaJRuntime rausziehen?
LambdaJ koennte man als Lisp Programm sehen, das von Hand nach Java uebersetzt wurde,
und ein Lisp Programm verwendet Lisp Runtime wie car, cdr, ... .
Falls ein LambaJ Compiler kommt, wuerden erzeugte Java Programme dieselbe Runtime verwenden.
Fuer interpretierte Programme gibts die Builtin-Wrapper, die Parameter-Checks machen und
die Argument-Liste in Argumente wandeln.
-> public static nested class LambdaJRuntime + "import static LambdaJ.*"
   damit gaebs nur wenig Aenderungen in LambdaJ, und externer Code haette auch Zugriff mittels "import static LambdaJ.*" 


let* mit einfacher syntax geht nicht im compiler:
JMurmel> (let (a) (write a))
nil
==> t
JMurmel> :r
nil
==> t
JMurmel> :res
JMurmel> (let* (a) (write a))
nil
==> t
JMurmel> :r
history NOT run as Java - error: not a symbol: a
error occurred in S-expression line 1:1..1:20: (let* (a) (write a))
JMurmel>

das suffix * wird für "sequentielle zuweisung" benutzt (let*, do*, prog*, ...)
-> NICHT für rplaca* & co benutzen

checken was passiert wenn require 2x die gleiche datei bekommt, aber mal als ./xxx und mal als d:/.../xxx
-> syntax ist (require modulname optfilespec) -> object
   gehasht wird "modulname", wenn verschiedene modulnamen verwendet werden, wirds 2x geladen
   -> das ist eher schlecht, d.h. diese syntax ist schlecht, modulname sollte in der datei drinstehen, so wie in CL
     -> warum brauchts überhaupt modulname + optfilespec? vielleicht besser modulname ODER filespec, und gehasht wird der kanonische pfad?!?
-> umbauen in (require filespec), gehasht wird der kanonische pfad
  -> oder vielleicht doch "provide" so wie in CL und elisp?
  -> in CL sind require und provide funktionen, ist aber schwierig im murmel compiler

bei progn usw castet der compiler args auf ConsCell
-> (progn . 1) -> CCE

compiler: bei opencoded wie car sollte argumentanzahl zur compilezeit gecheckt werden, dafür aber nicht zur laufzeit
-> derzeit wird zur compilezeit nix gecheckt, dafür werden z.t. die "normalen" funktionen mit argcheck eingebaut

lambda calls haben im generierten code einen argCheck. bei let & Co ist der argcheck unnoetig
-> ist doch nötig, ausser es würde zur compilezeit gecheckt

progn toplevel expandierung kann ggf. in prognToJava gemacht werden?
-> nein, kann nicht, weil die forms die ein toplevel progn enthält als toplevel forms behandelt werden sollen

mlib-test: tests constantly wieder entkommentieren
-> defmacro als nicht-toplevel form und macroexpand-1 im compiler

mlib: case sollte mit eql checken?
CLHS sagt "These macros allow the conditional execution of a body of forms in a clause that is selected by matching the test-key on the basis of its identity."
SBCL macht eql:
D:\robert\projects\jmurmel>sbcl220
* (macroexpand-1 '(case a ((1) 'one) (2 'two) ((3 4) 'threeorfour) (t 'other)))
(LET ((#:G430 A))
  (DECLARE (IGNORABLE #:G430))
  (COND ((OR (EQL #:G430 '1)) NIL 'ONE) ((EQL #:G430 '2) NIL 'TWO)
        ((OR (EQL #:G430 '3) (EQL #:G430 '4)) NIL 'THREEORFOUR) (T NIL 'OTHER)))
T
*
-> mlib sollte wohl auch eql nehmen, und key listen mit nur einem element von member auf eql umstellen

Compiler: setq in closures gibt code der nicht kompiliert: final or effectively final...
(let* (a) (progn (setq a 1) a)) ist das einfachste beispiel dafür: let* hat Java variablen, das geht nicht, letrec hat members, das würde gehen
  -> unittest machen
-> letRecToJava reusen, aber das environment zu anderem zeitpunkt befüllen (nicht alle vor der initialisierung sondern zug um zug)

mlib-test auch mit compiler laufen lassen (sobalds load und setq gibt)

rplaca für ArraySlice sollte nicht schwer sein

Iterator von ListConsCell und ArraySlice funktionieren nicht bei Mischungen aus ListConsCell und ArraySlice
gaben falsches ergebnis, werfen jetzt exceptions.
umbau von iterator auf cdr hat den nachteil, dass cdr(ArraySlice) jedesmal new ArraySlice macht, wirkt sich u.a.
in der Murmel funktion append und listToArray aus
-> reparieren oder ausbauen
-> ggf. statt zweier Iteratoren einen Iterator im Interface, der ListConsCell UND ArraySlice versteht?
-> vielleicht auch forAll ausprogrammieren?

Compiler: let* dynamic sollte als unsupported angemeckert werden (oder supported werden)

compiler: let* dynamic ist eigentlich let dynamic

compiler let/ let* dynamic: doppelte bindings abweisen bzw. behandeln

isSymbol sollte intern("+") == op verwenden ?!?

(let* dynamic ((a 1)) a) sollte eig einen fehler geben, geht aber im interpreter?!?

compiler: argcheck bei let/ let*/ letrec sollte unnötig sein? bei named... ist es nötig

let dynamic im interpreter

gabriel 3.02_stak.lisp vereinfachen

write, writeln, lnwrite sollten optionalen parameter "print-escape-p" bekommen, default t

speed auf 0 wenn reduzierte features?

eql opencoden

jm --lambda kracht, jm --lambda+ geht

assq exposen

opencoden im interpreter

mlib: conjoin, disjoin

in formToJava:
-> methoden openCodeFuncall() und openCodeFuncall2() rausrefactoren (mit oder ohne argcheck?)
-> ggf. den argcheck der opencoded operatoren aus formToJava rausschieben
-> den ganzen opencode block nach unten zu functioncall schieben, ggf. in eine methode rausziehen, ggf. tabellengesteuert?

makeAddOp() und makeSubOp(): richtig benamsen und beschreiben. die generieren keinen operator sondern berechnen ein ergebnis

format und formatLocale in eine methode zusammenziehen (mit boolean flag "locale")
-> sind großteils copy&paste

letXX aus eval rausziehen, return tupel(form, extenv)

--no-nil geht nicht richtig: reparieren oder ausbauen

feature-flags: nil und t sollte nicht sofort wegfallen, erst bei --lambda+
usage korrigieren: let, let*, ...
--no-ffi

mlib: (require srfi/1)
      (circular-list 1 2 3)
oder alexandria: 
Function: circular-list &rest elements
    Creates a circular list of elements. 

gesondertes flag für turtle?

load sucht nicht im directory vom file sondern im libdir

floor, ffloor mit zweitem optionalen parameter? [f]ceiling, mod, rem, [f]truncate detto
-> bei opencoding im compiler: nach floor1 oder floor2 expandieren, je nachdem ob 1 oder 2 argumente

ggf. den langen switch für getsymbol nicht mehr dynamisch generieren sondern hardcodieren?

00_tak_apo: null waere opencoded, not nicht. compiliert ist null doppelt so schnell, interpretiert wirds 40% schneller

for(...toCharArray) durch normales for ersetzen

CL sleep uebernimmt sekunden, Murmel internal time units ?!?

im interpreter gibts x-mal "if (!(a instanceof Number)) throw new LambdaJError..." und in MurmelJavaProgram gibts number()

generierte variable resultNN in formsToJava reinziehen, umbenamsen nach ignoredNN

truncate umbenamsen weil das macht kein truncate, sondern double->long mit overflowcheck
-> checkedD2L oder checkedDoubleToLong

members von LambdaJ umsortieren: am anfang solls public interfaces geben

mod und rem opencoden
cl_round() inlinen, cl_rem() auch

Turtle funktionen in MurmelJavaProgram überarbeiten: erst wird ein ArraySlice gemacht, der wird nur für varargsMinMax und car() gebraucht
-> KEIN arrayslice, neues varargsMinMax, args[0] statt car(a)

ListBuilder sollte ggf. doch (optional?) cons mitzählen? vielleicht CountingListBuilder extends ListBuilder und cons wird überschrieben?
append ist fishy: koennte static sein, oder ConsCells sollten alle mitgezählt werden, auch die vom Listbuilder, s.o.
  beim aufruf von append als interpreter builtin wird als argument list->array gemacht - ineffizient

MurmelJavaProgram verwendet bunt gemischt dbl(Object) und asDouble(String, Object) (und asInt(), asFrame(), ...),
varargsX() aus MurmelJavaProgram vs. varargsMinMax() aus LambdaJ

checken ob sb.append(printSEx()) durch printSEx(sb) ersetzt werden kann

 
package private machen:
current_frame???
init???
findJavaMethod???
checkedToLong???
printSEx???
class ArraySlice???
listToArray???

der rest ist "CL runtime", ggf. auch umsortieren/ gruppieren:
assoc
assq
atom
car, cdr
characterp
cl_eql
cl_mod
cl_signum
cl_truncate
consp
dec, inc
eval(Object,Object)
format, formatLocale
gensym
getXXXTime
integerp
intern
listp
listToString, stringToList
lnwrite, write, writeln
numberp
sleep
stringp
symbolp
trace, untrace


(setq format 1) erzeugt ungueltigen code
-> eintrag im environment ansehen, wenn CompilerPrimitive drinsteht, einen hack aktivieren (und environment eintrag patchen ?!?)
   -> oder "unsupported" melden

(let dynamic ((format... erzeugt ungültigen code

notReserved & co müssen im compile nicht ein zweites mal umgesetzt werden

Compiler.libdir ist unused?!?

wird "notReserved" im interpreter 1x oder bei jedem call gecheckt?

(let ((t 1)) (write t)) geht im compiler obwohl t reserved ist, (let ((let... geht auch
SBCL: (let ((t 1)) (write t)) gibt fehler, (let ((let 1)) (write let)) geht
-> interpreter und compiler angleichen, ggf. reserved words überdenken

--jar findet load files nicht

vielleicht variablen von typ ConsCell mit präfix c oder cc benamsen

--lambda+ bzw. --no-nil geht immer noch nicht weil der reader nil ausspuckt
--min+ --no-t hat doch t im environment

argcount check fehlt für einige interpreter primitives, z.b. get-internal-real-time

zeilennummern in fehlermeldungen bei require und load, und filenamen generell

filenamen in fehlermeldungen

named let* und letrec kompilieren zu endlosschleifen

compiler: eine methode für argslists für functioncalls rausziehen, die schreibt ein einziges null argument als "(Object)null" (und keine argumente als (Object[])null ?)
-> dann kann an anderen stellen "null" statt "_nil" geschrieben werden -> schneller
-> oder einfach nie nil als "null" schreiben, sondern immer "(Object)null"?
-> und eine leere argumentliste als NOARGS - fehlt wsl. bei functioncall in emitForm, vielleicht noch woanders

ein programm das nur nil enthält führt zu java compilerfehler
nil
:r
-> fehler

in readerfehlern fehlt der filename

(Object... args) darf ggf. nicht generiert werden, immer args+rsfx, weil sonst referenzieren freie variablen ggf. den falschen nestinglevel
-> reparieren bzw. durch (Object... ignored) ersetzen

die ganzen protected methoden in MurmelJavaProgram erzwingen alle $access methoden
-> auf public stellen

warum ist apply ein reserved word? sollte eine funktion sein
apply ist eine special form die sich wie eine funktion verhält, sollte aber eine funktion sein
-> umbauen wie eval?!?

emitQuotedForm könnte einen fastpath für 2-element listen haben: cons(lhs, cons(rhs, null))

wenn fatal in compiliertem code aufgerufen wird, kommt am ende
  history NOT run as Java - error:
die meldung ist falsch, weil gelaufen ists ja

compiler: applyOpencode ist vielleicht nicht mehr nötig, eine spezialbehandlung für apply sollte ggf. in opencode rein
  + isLast durchreichen und auswerten?

quoted forms deduplizierung wieder aufdrehen, tests anpassen

compiler: ggf. t als condition optimieren (nicht (_t) != null ausspucken sondern true),
 ggf. den defaultfall in cond optimieren (aber nur wenns der letzte ist?!? wobei: alles was im cond nach t käme, wär eh dead code?!?)

die methoden im compiler, die code ausspucken umbenamsen: emit...

:: opencoden? und/ oder auf MethodHandle umstellen?

mit optimize speed 0 und 1 testen

in emitForm: bei function call könnt ma schaun *was* aufgerufen werden soll, und im falle von compiler primitives (und ggf. "(:: ..."))
gleich den call ohne funcall() ausspucken. für :: brauchts größere umbauten, nicht mehr ""(MurmelFunction)args->..."
-> geht nur/ macht nur sinn für ::

mlib checken, obs ggf. zu functions zusätzlich makros geben sollte
-> z.B. (defmacro not..., ggf. alle "aliases"?

jeweils "since" in mlib anführen



siehe https://github.com/ruricolist/serapeum/blob/master/REFERENCE.md#plist-keys-plist

(doplist (k v plist)
  forms...)

(serapeum:plist-keys '(:a 1 :b 2))
;; (:A :B)

(defun plist-keys (plist)
;  "Return the keys of a plist."
  (collecting
    (doplist (k v plist)
      (collect k))))

auch: plist-values


inspired by serapeum:
(defmacro summing (startval . body)
...

expandiert irgendwie in eine labels-form (und eine let-form für accumulator, oder let* für beides), die hat sum als lokale funktion und sum summiert das argument auf
im body kann man sum aufrufen
nach body gibts "return summe"

passt wsl für vieles, nicht nur summieren. vielleicht ein metamakro, und den akkumulator (ein closure) und akkumulatorname als makro-parameter?
-> kann man das primesieve damit abbilden?
-> siehe auch serapeum with-collector und collecting

tests für with-accumulator, summing, collecting, reverse-collecting, plist-keys, plist-values

funktion profile mit JFR-events?

wär ein overload MurmelJavaProgram.tailcall(MurmelJavaProgram... nicht doch sinnvoll?
-> z.b. für progn in der tailposition

number() (schnell) ist meist gefolgt von cast auf Number (langsam)
-> number soll gleich Number liefern

julia.lisp: unter Java17/18 ist das fenster größer als Java8 ?!?

lst umbenamsen in requireList()

1+, 1- sollten auch byte, short, int zu Long machen, und nicht zu double

ggf. die konvertierungsmethoden die Object nehmen überladen, falls der Compiler den typ kennt, zumindest overloads mit Long und Double (und ggf. long+double)?

in der runtime kein .doubleValue() verwenden sondern toDouble(), interpreter und compiler
-> casts auf Number sollte es auch fast keine mehr geben
-> argchecks auch nicht/kaum

-> manche number konvertierungen akzeptieren alle Java Number typen, andere und numberp nur Double und Long
   -> numberp umstellen dass alle Java Number true sind, anynumber&co weg

-> as... konvertieren, require... checken nur den typ ohne konvertierung
   oder vielleicht to... statt as...

signum umbauen dass BigInteger und BigDecimal geht, kein longValue()

in den as... methoden ohne check abschneiden, genauigkeitsverlust oder überhaupt vorzeichenwechsel (integer wraparound) ist nicht ok
-> dezimal->integer verbieten: in toInt, toShort, ...: nicht requireNumber sondern requireIntegralNumber, die gibt einen fehler wenn dezimalstellen != 0 sind
-> bounds checks einbauen nicht nur byteValue(), intValue(), ... longValue()

samples aufräumen, ack_bm löschen

rplacd für ArraySlice ist problematisch: man könnte ins array an der richtigen stelle was anderes reinpatchen,
aber wenns andere arrayslices mit demselben array gibt (mit anfang NACH der rplacd stelle), dann wirkt sich rplacd
auf die anderen ArraySlices ggf. nicht richtig aus
-> faktisch darf man halt nicht die argumentliste einer varargs-funktion rplacd-en

Java overflow: bei long usw. gibts wraparound, bei double gehts nach +-Infinity (sobald man soviel dazu addiert/subtrahiert/multipliziert dass es trotz begrenzter auflösung darstellbar ist)
-> Murmel übernimmt Java wraparound, ausser: 1+, 1- wenn das argument byte/short/int/long ist - dann gibts fehler bei under/overflow
-> wraparound spielt eigentlich nur bei to... eine rolle und da gibts checks, gerechnet wird in double
-> vielleicht teilweise so lassen und dokumentieren?
   -> * bei allen Operationen werden die Argumente (alle Java Number Typen sind erlaubt) nach Double konvertiert, Fehler falls Argumente nicht in ein Double reinpassen.
        Ergebnis ist immer double, Over/ underflow geht gegen +-Infinity.
        Z.B.: Double.MAX_VALUE + 1 == Double.MAX_VALUE weil +1 aufgrund der Auflösung keinen Unterschied macht.
              Double.MAX_VALUE * 2 == +Infinity
      * ausser: 1+, 1-: Byte, Short, Integer und Long Argumente werden nach Long konvertiert. Ergebnis ist Long, Over/ underflow ist Fehler
                        restliche Argumenttypen wie oben
      * ausser: ceiling, floor, round, truncate: Ergebnis ist Long, Over/ underflow ist Fehler
      * ausser: signum: Ergebnis ist "signed prototype" entweder Long -1/0/1 oder Double -1.0/-0.0/0.0/1.0

integerp umstellen dass auch BigInteger t ist?
-> floatp auch umstellen?
-> oder beide bekommen einen optionalen parameter "java-too-p" ?
-> wie soll das zusammenspiel mit numberp sein? derzeit kann numberp t liefern, und integerp und floatp liefern beide nil
   -> dokumentieren: numberp ist t für alle Java nummer typen, integerp ist t für Murmel integral typ, floatp ist t für Murmel Dezimal typ


Multiple values: VALUES, MULTIPLE-VALUE-BIND und MULTIPLE-VALUE_CALL müsste reichen?
VALUES hat als returnwert das erste argument, und verpackt ALLE (oder die restlichen?) argumente in ein Object[]
  und steckt dieses in eine globale variable (member von LambdaJ bzw. von MurmelJavaProgram).
MULTIPLE-VALUE-BIND und MULTIPLE-VALUE-CALL lesen das array wieder aus.
CLHS: VALUES -> funktion, MULTIPLE-VALUE-BIND -> special operator, MULTIPLE-VALUE-CALL -> special operator
SBCL: VALUES -> funktion, MULTIPLE-VALUE-BIND -> macro, MULTIPLE-VALUE-CALL -> special operator
VALUES kann auch in setf verwendet werden: (setf (values a b) (floor 7 2)), das ist aber in CL erst rel. spät dazugekommen,
  brauchts also nicht im ersten wurf, scheint aber nicht schwer:
    * (macroexpand-1 '(setf (values a b) (floor 5 2)))
    (MULTIPLE-VALUE-BIND (#:NEW1 #:NEW1)
        (FLOOR 5 2)
      (VALUES (SETQ A #:NEW1) (SETQ B #:NEW1)))
MULTIPLE-VALUE-BIND übernimmt nur eine VALUES form, MULTIPLE-VALUE-CALL übernimmt 0 oder mehrere
LIST-VALUES, VALUES-LIST, usw. sollten nur macros sein, die nur nice to have sind
-> im REPL muss auch magic eingebaut werden, damit allfällige sekundäre results ausgegeben werden
-> multiple-value-bind könnte ein macro sein, das nach multiple-value-call + lambda expandiert

mlib: multi-value-compose


abgeleitete wrapping symboltables erzeugen unnötigerweise die wellknown symbole ein zweites mal
-> symbolerzeugen irgendwie rauslösen und im konstruktor nur aufrufen, wenns benötigt wird
-> oder sollte nicht die klasse sondern das interface abgeleitet werden?
   -> filepath und position soll aber nicht delegiert werden

-> die liste mit den intern-den symbolen sollte nicht im parser stecken sondern im interpreter, momentan funktionieren die delegierenden parser nur durch zufall:
   funktionieren tuts, weil der delegierende parser eh wieder zur ersten und einzigen liste mit intern-den greift. dann kann die liste auch gleich im interpreter stecken,
   alle parser nutzen die gleiche liste des interpreters, und die liste (und alle wellknown symbols) wird im konstruktor des interpreters erzeugt
   -> wenn alle wellknown symbols vom interpreter konstruktor erzeugt werden, können sie auch final sein, und in eval gibts switch
      symbols wie backquote usw. die nur der parser braucht, sollten wsl auch zum interpreter
-> delegierende parser werden auch ggf. mit den falschen features erzeugt (nämlich mit allen), d.h. in load files ist alles erlaubt
-> featurelist kann wsl auch zum interpreter
-> wenn alles entwirrt ist, hat der parser nur mehr so wenig state, dass obiges problem mit doppelt erzeugen eig nicht mehr existiert
-> in setSymtab() wird auch noch einiges resetted. das passt wenn setsymtab() im zuge der (re-)initialisierung gerufen wird, aber nicht bei load oder require

dass Parser die beiden interfaces SymbolTable und ObjectReader erweitert, macht auch nicht viel Sinn.
-> wsl. sollte es ein symboltable klasse geben die macht nur intern, und interpreter und reader nutzen beide das gleiche objekt.


read sollte am ende nicht nil liefern, sondern fehler oder übergebenes symbol
   -> oder einfach ein neues symbol eof einführen (self-evaluating wie t)
-> "jm murmel-langref.lisp" und "jm --run murmel-langref.lisp" enden beim ersten toplevel "nil"
   "jm < murmel-langref.lisp" und "jm --run < murmel-langref.lisp" geht

-> der repl verschluckt auch nils:
JMurmel> 'a

==> a
JMurmel> 'b

==> b
JMurmel> nil

==> nil
JMurmel> :l
(quote a)
(quote b)
JMurmel>


values&co dokumentieren, in usage aufnehmen

eval sollte ggf. von zeit zu zeit das interrupted flag checken?!? MurmelJavaProgram auch?


Java interfaces für callbacks implementieren:
-> special form oder funktion? -> kann eig funktion sein
-> (javaproxy "java.awt.event.MouseListener" "mousePressed" lambda-or-symbol1 "mouseReleased" lambda-or-symbol...)

der interpreter sollte argumenttypen umwandeln, gleich wie der compiler

macroexpand-1 könnte/sollte jetzt values liefern

LambdaJSymbol.wellknownSymbol sollte ggf nur dann != null sein, wenn das symbol mittels features auch wellknown ist
-> dann brauchts die ganzen != null checks nach dem case: nicht mehr (eval und evalOpencode)

die printEscape verzweigung sollte eigentlich nicht in write() stecken sondern im lispprinter/ ObjectWriter

format sollte eigentlich auch printSEx benutzen, derzeit verwendet Java für %s einfach toString() der jeweiligen argumente
-> toString() sollte überall geeignet definiert sein !?

:: umbenamsen in jcall, proxy umbenamsen in jproxy

*features* exposen?

:: issues
methoden die checked exceptions werfen geben im compiler ungültigen Java code
((:: "java.util.concurrent.Callable" "call") (jproxy "java.util.concurrent.Callable" "call" (lambda () "hello")))
-> /MurmelProgram.java:25: error: unreported exception Exception; must be caught or declared to be thrown
           }))).call();

symbolprinting stimmt nicht:
'1+        -> |1+|
'|"bla"|   -> "bla"
-> checken ob das erste zeichen eine ziffer ist ist eher hinderlich
   |name| solls geben, wenn das erste zeichen ein | oder " ist, oder wenn der symbolname dem double oder long pattern entspricht

(integerp 1.): SBCL gibt t, Murmel gibt nil
-> http://clhs.lisp.se/Body/02_ca.htm#syntaxfornumerictokens
   "2.3.1 Numbers as Tokens" sagt:
   "digits + ." ist ein integer im dezimalsystem, ohne punkt im "current input radix"
   float sind immer dezimalsystem: optionale ziffern . "ziffern und/ oder exponent"
-> vielleicht ein pattern für digit+ '.' und dann einen fehler ausgeben, also faktisch den dezimalintegertrick verbieten?

init(), parser vs. in aufraeumen


multiline comments sind #|...|#. wenn #!...!# auch zulässig wäre, würden shebang scripts gehen:
#!/usr/bin/env java -jar jmurmel.jar --shebang
!#
die neue option --shebang müsste zuallerst ein "--" an der stelle nach dem filenamen ins String[] args reinzwicken,
eigentlich: das argument das nach --shebang kommt (das muss der filename sein), ersetzt --shebang, und dorthin wo der filename gestanden ist, kommt "--"

bei --script sollte ggf. kein result geschrieben werden
und/ oder das result iwie in einen exitlevel umgelenkt, vielleicht nil-> exit(0), number-> exit(number), sonst exit(-1)
vielleicht zus --endresult, default ist false


car und cdr auf strings und symbols macht nur probleme
-> (list-length '(a . b)) -> 3 !?! sollte fehler geben
-> ist auch blöd zum opencoden
-> und vor allem ist das eigentlich das typsystem, und zwar ein schlechtes
   -> Murmel hat ein typsystem (für values), ist aber ad-hoc durch die instanceof ketten "implementiert", sollte an CLTL2 angepasst werden 


die members sCond, sLabels usw. braucht eigentlich nur der compiler. die members könnten zum compiler verschoben werden,
oder der compiler macht jeweils intern(), oder der compiler vergleicht auch WellknownSymbol.
gilt auch für die meisten oder für alle primitives wie sCar, sCons usw.
opencode() könnte/ sollte auch auf switch umgestellt werden, dann braucht auch der compiler von den 
würde die größe von LambdaJ drastisch verringern, derzeit 296 byte.


wenn funcall und tailcall einen weiteren parameter "finally" bekämen, könnte unwind-protect umgesetzt werden, und letXX dynamic könnte TCO werden. conditions gehen damit aber nicht
CL hat catch, throw und unwind-protect als special forms.
unwind-protect sollte wsl isoliert von catch/throw betrachtet/umgesetzt werden
catch/throw sind die non-local variante von block/return-from
mit catch+throw+defstruct müsste man eigentlich conditions nachbauen können
-> LambdaJError sollte einen zus member "LambdaJSymbol tag" bekommen, tag ist das tag aus "CLHS Special Operator THROW" http://clhs.lisp.se/Body/s_throw.htm#throw, und wsl. einen member
   für das ergebnis von result-form
-> eval bekommt ähnlich wie "restore" eine zus lokale liste "ConsCell catchtags".
-> der schleifenbody wird in try/catch LambdaJException eingepackt, der catch handler schaut ob e.tag in der liste enthalten, falls ja -> return result-form, falls nein-> rethrow.
   -> vielleicht die zus member nicht in LambdaJError reinpacken sondern klasse (LambdaJCondition?) ableiten, und im schleifenbody gibts try/ catch LambdaJCondition
      primitives sollten exceptions in geeignetes tag umlenken (dann kann das try/catch in applyPrimitive() entfallen), oder applyPrimitive() umbauen
   -> type-error usw. (die wellknown tags) brauchen wsl. nicht im environment sein
-> wsl brauchts doch einen zus parameter "catchtags". wenn für ein throw kein catchhandler existiert, soll control-error signalisiert werden, und zwar im environment des throw.
   -> also checken ob das tag in der lokalen liste "catchtags" ist -> return result
      sonst checken ob das tag in der liste ist die eval als parameter bekommen hat -> rethrow
      sonst signal(control-error) aufrufen (sobalds signal gibt), oder eval((list 'throw 'control-error, ...), ...) bsw. form=(list 'throw 'control-error, ...); continue tailcall;
   -> die lokale liste catchtags könnte wsl mit dem parameter initialisiert werden, und mit für die lokale suche bricht man ab wenn lokalptr == parameter

mlib: length muss auch vector unterstützen (ggf. length nach Murmel schieben)
      div funktionen sollten "sequence" können, können aber nur list (und string?!?)
      (setf (svref...
sv->list, list->sv?

mlib: remove und remove-if sollten sequence akzeptieren

eval gibt bei fehlern/ malformed locationinfo aus, expandForm nicht
-> try/catch/rethrow analog eval einbauen


jetzt wos einen vorgeschalten macroexpand/ check pass gibt, könnten einige checks in eval wegfallen
-> checks in expandForm vervollständigen (v.a. duplicate symbols in let, letrec und lambdalist, und check ob sf als variable verwendet wird)
   checks in eval ausbauen oder durch asserts ersetzen
-> tryExpand() müsste unnötig sein
   -> ist es (noch) nicht, weil (progn (load...) (macro...)) nicht richtig verarbeitet wird: defmacro im load file werden erst später verarbeitet
-> im compiler fällt auch bissl was weg
-> ggf. in expandForm() (defun... -> (define (lambda... auflösen
-> ggf. in expandForm() einfache optimierungen machen wie (cdr (cdr... -> (cddr, wenn speed >= 1
   -> das beisst sich mit evalOpencode()
   -> es könnte aber auf eine versteckte specialform "primcall" umgeschlüsselt werden, ähnlich wie im primcall branch aber vorgeschaltet statt just-in-time
-> vielleicht auch (let () forms...) -> (progn forms...), oder (let () form) -> form, oder (if (null form) a b) -> (if form b a)
-> sollte alles mit patterns möglich sein?!

Murmel verwendet long->double bei math operatoren und das verwirft genauigkeit:
(define v1 (floor (expt 2 55))) ; ==> v1
(define v2 (1+ v1)) ; ==> v2
(= v1 v2) ; ==> t, sollte nil sein
-> entweder fixnums auf integer umstellen, oder nur [-2>>52 .. 2>>52] zulassen
   -> fixnum als 32 int wär schlecht, weil das kann get-internal-real-time nicht abbilden. 52 bit reicht aus

http://clhs.lisp.se/Body/f_map.htm:
map result-type function &rest sequences+ => result

map-into sollte sequence verarbeiten, kann derzeit nur list
map-into result-sequence function &rest sequences => result-sequence

codeerzeugung kann auch ausgemistet werden, v.a. let

make-bitvector, sbit? bitvector vielleicht als boolean[]
-> list->bitvector

mlib hat m%sequence->list und m%s2l, die machen fast dasselbe

string->list, simple-vector->list usw. akzeptieren nil als argument und liefern nil
-> nil sollte wsl verweigert werden, weil nil ist kein string bzw. simple-vector

#* soll einen bitvector länge 0 geben

Murmel liest 0101 als variable, sollte eine zahl sein (101)

(string= "a" #\a) sollte t liefern

sT, sDynamic, ... könnten static final sein
-> Konstruktor LambdaJ erzeugt keine neuen Objekte mehr, sondern steckt die bestehenden in die symboltabelle


mlib: konsequente namensgebung der parameter:

lst, lists, more-lists
alist
plist
seq, sequences, more-sequences

pred, test
func

value, item, obj
n... number
str

exp -> loop-spec
form, forms, body


scan-multiple refactoren: statt push+reverse -> append-to vgl collect

scan-multiple umbauen dass generators nach dem ersten nil nicht mehr aufgerufen werden
-> und umbenennen nach scan-multiple, zusätzlich (scan-concat generator . more-generators)... nudelt einen nach dem anderen ab

einige mapXX funktionen sind rekursiv aber nicht tail rekursiv -> kann stackoverflow geben
-> mapc, mapl benutzen progn, sind ok
   mapcar, maplist benutzen cons, sind nicht ok
   mapcan, mapcon benutzen append, sind nicht ok

scan sequence erweitern:
(scan sequence [start-idx [n]])
-> oder (scan sequence [start-idx [every-nth [end-idx-excl]]])

(scan-range generator first [count])... Java hat skip und limit als getrennte operationen
-> oder (subsequence skip . maxlength)
   list: sublist, error falls skip > length, ggf. nils hintendran, vielleicht eine kopie, vielleicht nicht, oder doch kopie garantieren?
   vector: neuer vector, allenfalls error falls skip+maxlength > originallength
   generator: neuer generator
   CL hat (subseq start [endexcl]), geht auch für setf (setf für generator wär problematisch, für string auch)
-> wenn scan auch generator unterstützt (und skip und count), brauchts kein scan-range 

wenn in einem defun ein macro benutzt wird das erst später definiert wird, gibts z.B.
java.lang.AssertionError: c:\robert\jmurmel\samples.murmel-mlib\mlib.lisp:118:3..118:60: unexpanded macro call: unless

gscheite implementierung von char, schar (?) in LambdaJ
-> char für CharSequence, schar für String

reduce from-end-p=t ist nicht endrekursiv

mlib:
nconc ist nicht endrekursiv
(nconc (list* 1 2 3) nil) sollte (1 2) liefern
-> tests + reparieren


gibts erst eine undefinierte lokale variable, und dann eine gleichnamige korrekte lokale variable,
dann wird der fehler nicht erkannt und es kommt zu einem Java compile fehler,
weil javasym() findet die zweite variable und putzt sie aus implicitDecl weg
-> es sollten nur gefundene globals aus implicitDecl weggeputzt werden, ggf. ein set mit define/defun symbolen mitführen

JMurmel> (defun f() seq)
JMurmel> (defun f2 (seq) seq)
JMurmel> :r
implicit declaration of seq
/MurmelProgram.java:21: error: cannot find symbol
        return _seq.get();


- Primitives ggf. nachziehen
    vector-length akzeptiert CharSequence, vectorp aber nicht
- Java FFI Tests erstellen, z.B. (deftest xxx (vectorp ((jmethod "java.lang.StringBuilder" "new" "String") "123")) t)


svset, sbvset: parameter sollten sein: sequence, newvalue, index
-> wenn index der letzte parameter ist, dann kann man leicht auf mehrere arraydimensionen erweitern,
   bzw. ein allenfalls kommendes aset wäre (aset array newvalue index1 index2...)
-> oder an sbcl (SETF AREF) anlehnen:
(SETF AREF) names a compiled function:
  Lambda-list: (NEW-VALUE ARRAY &REST SUBSCRIPTS)
(SETF SVREF) names a compiled function:
  Lambda-list: (NEWVAL SIMPLE-VECTOR INDEX)


- vielleicht StringBuilder einbauen:
  "asdf" liefert String
  (simple-string obj) == obj.toString(), liefert String
  (string obj) == new StringBuilder(obj.toString())
  (make-array 5 'character) liefert new StringBuilder(5), also leerstring, initial capacity 5
  -> in CL liefert das ein simple-array mit fillpointer=false, adjustable=false, inhalt 5 x #\0, StringBuilder würde adjustable=true entsprechen
  -> #\Nul wird von CL write stillschweigend verschluckt, oder vielleicht verschluckt die Windows console Nul?
  (char s 0) gibts bereits, sbset dazu

- oder: (string obj) liefert obj.toString().toCharArray()
  und:  (make-array 5 'character) liefert new char[5]
  nur stringliterale bleiben immutable java.lang.String


mlib: error beschreiben

langref: bitvector beschreiben


- ArrayList, StringBuilder, BitSet integrieren als "nicht simple-":
  t                                 Murmel prädikat
    vector                          vectorp
      string                        stringp             r/w und adjustable      CharSequence, StringBuilder() 
        simple-string               simple-string-p     r/w, nicht adjustable   char[]
          (immutable-simple-string)                     ro                      String, wird nur mit stringliteralen erzeugt
      
  -> (make-array size [type [adjustablep]])
  -> vector-push-extend, adjustable-array-p

vielleicht sequence-ref in core Murmel, macht dasselbe wie elt
und sequence-set
-> damit brauchts kein gesondertes aref, in mlib könnten typecases wegfallen, hätte auch einen fastpath für nth, insb. für arrayslice
-> elt gibt fehler beim lesen des letzten elements einer dotted list
   seqref gibt keinen fehler, seqset schon

-> seqref, seqset dokumentieren (dotted lists!)

Typsystem:
- beschreiben, welche Murmel Typen als welche Java Datentypen implementiert werden
- beschreiben, welche Java Typen auch als Murmeltyp akzeptiert werden, z.B. numberp Number -> t (steht in murmel-langref eh schon unter "numberp, integerp, floatp" beschrieben)


(let (x) (null (setq x 1)))
-> compile fehler
/MurmelProgram.java:23: error: unexpected type
        return (((Object)args2[0] = 1L == (Object)null) ? _t : null);
                 ^
  required: variable
  found:    value
/MurmelProgram.java:23: error: incomparable types: long and Object
        return (((Object)args2[0] = 1L == (Object)null) ? _t : null);
                                       ^
2 errors



checken ob mlib funktionen ArrayList usw. verarbeiten können
-> tests mit (make-array N t t) als argumente
-> checken ob in den typecase clauses was fehlt

map-into sollte sequence unterstützen, nicht nur list


manche funktionen die sequences nehmen sollten (map?) schlucken generators, andere nicht, kann auch von der anzahl argumente abhängen
-> vielleicht neue funktion m%scan einführen und verwenden
-> reverse kann nicht mal adjustable-arrays, nreverse detto

  elt         kein generator
  length      kein generator
! reverse     kein generator
! nreverse    kein generator
! remove-if   kein generator
  remove      kein generator (nutzt remove-if)
  map
  map-into
!   1 seq     kein generator
    2+ seq
! reduce      kein generator


aref in mlib? eher nicht
-> wenn schon dann sollte aref in murmel sein und java.util.List unterstützen
elt in mlib? eher schon
vielleicht statt sbit/bvset
-> (sbvref bv idx) -> boolean, (sbvset bv idx), (sbvclr bv idx)
-> sbit in mlib
java.util.BitSet ist eigentlich ein bitvector, ggf. in jmurmel anbinden

scan-multiple brauchts eig. nur bei mehreren sequences, bei einer sequence wär scan effizienter

mlib:
XX->list ersetzen durch generators

fill in Murmel einbauen: fill sequence item &key start end => sequence http://clhs.lisp.se/Body/f_fill.htm
-> oder fill-vector in murmel

vielleicht primitive "simplify" oder besser "simplify-vector", die macht aus adjustable arrays simple-vector/ simple-string/ simple-bit-vector
-> könnte in mlib verwendet werden statt collect list und list->xxx, und vector-push-extend verwenden
-> würde coerce dasselbe machen?
-> copy-seq kopiert einen vector in einen neuen simple-vector (und list in list)
   -> vielleicht copy-vector in murmel, und ggf. copy-seq in mlib

(eql 1 ((jmethod "Integer" "valueOf" "String") "1")) -> nil
-> weil eql mit Object.equals() implementiert ist
   kein problem für murmel, solange alles in long oder double berechnet wird und solange integerp nur für long t ergibt
   schlecht für Java interop

adjustable-array-p ist das einzige prädikat, das nicht T als parametertyp hat, (adjustable-array-p 1) gibt fehler.
in CL gibts viele prädikate für arrays, da kann das sinn machen
-> vielleicht in Murmel zulassen? anders als CL

rekursive aufrufe sind derzeit late-bound
-> compiler könnte das ändern, indem defuns eine (final) variable "recur" bekommen, und das geht ins environment
   -> aufpassen: das ändert die semantik von setq: (defun f...  (setq f... würd dann ggf. nicht mehr gehen?!?

make-array: statt adjustable=t sollte auch capacity erlaubt sein

gibt wieder jede menge access$ methoden
-> requireXX in MurmelJavaProgram aufräumen
-> MurmelJavaProgram.requireXXX sollten nur von generiertem JFFI code benutzt werden, sonst sollte LambdaJ.requireXXX benutzt werden

write & co könnten auch nil liefern statt t
-> oder das argument wie CL, 

read sollte EOF übernehmen

gensym symbole (beginnend mit #:) sollten beim symbol-printen NICHT in || gesteckt werden
derzeit wird irgendwie gemischt, es gibt mit und ohne ||:
JMurmel> (pprint (macroexpand-1 '(dogenerator (x (scan-multiple (scan '(11 22 33 44)) (scan #(111 222 333)) (scan 1 1 5)) 1 2 3 'done) (writeln x))))
(let
   ((#:g25 (scan-multiple (scan (quote (11 22 33 44))) (scan #(111 222 333)) (scan 1 1 5))))
   (labels
      ((#:g26 (x #:g24) (when #:g24 (writeln x) (multiple-value-call #:g26 (#:g25)))))
      (multiple-value-call |#:g26| (|#:g25|))
      (let ((x nil))
         1
         2
         3
         (quote done))))
==> t

der compiler macht selbstrekursive aufrufe early bound, der interpreter late bound
-> angleichen, defun soll das funktionssymbol in die closure stecken, nicht nur ins topEnv

WellknownSymbol.apply() ruft methoden auf, die die argumentanzahl nochmal checken
-> nur 1x checken. wenns in environment() keinen argcheck gibt, gibts änderungsbedarf

--no-vector

vielleicht doch slength (string-length) dazunehmen?

murmel-test.lisp: new Byte(String) ist deprecated (seit 9)
-> Byte.valueOf(String)
   Short, Integer, Long, Float, Double auch

jm --run scribbles\readfile-nio.lisp
-> Java compilefehler

auf parameter ConsCell oder Iterable umstellen
listLength

Dockerfile: abs workdir lt. hadolint, maven 3.8.6

emitJmethod: inline call scheint zu gehen, "emit a lambda that contains an argcount check" ist noch nicht vollständig implementiert

mehr JFFI tests in CallJavaTest, v.a. auch varargs, auch kompiliert
-> oder in murmel-test.lisp

varargs: primitive typen?!

die ganzen sbv... funktionen nach bv... umwandeln
-> simple-vector, string und bit-vector erben alle von vector
   hätten dann alle die gleichen funktionen
   gibt dann nicht mehr bv= und sbv= -> eine funktion weniger

vector könnte einfach in mlib implementiert werden:
-> (defun vector l (list->simple-vector l))
-> ginge auch für bit-vector, string
-> evtl zus optionalen parameter adjustablep für list->vector/string/bitvector
   list->simple-vector, list->simple-bitvector umbenamsen

vector-copy könnte auch adjustablep bekommen

- -> the current evaluated form
+ ++ +++ -> the recent evaluated forms
* ** *** -> the recent primary results
/ // /// -> all the returned values, each as a list
-> CL namen mit @ vornedran verwenden


Murmel könnte (vector-add v elem) bekommen, mlib: (defun vector-push-extend (elem v) (vector-add v elem)) + defmacro
-> und vielleicht den ersten parameter von svref/ sref/ bvref/ seqref von vorne an die letzte stelle schieben (und setf/ get-setf-expansion anpassen)
   dann hätten alle sequence funktionen die sequence als ersten parameter
   -> besser für ->


langref: varargs vereinheitlichen
optionale-form?
0-oder-mehrere*
1-oder-mehrere+
[erstes-optionales-argument [zweites-optionales-argument]]



JFFI: vararg parameter gibts: int...
-> arrays? int[]
JMurmel> (define al ((jmethod "java.util.ArrayList" "new")))

==> al
JMurmel> (define to-array (jmethod "java.util.List" "toArray" "Object..."))
==> to-array
JMurmel> (to-array al #())
==> #()
JMurmel> :r
/MurmelProgram.java:30: error: no suitable method found for toArray(Object)
        try { final Object value = ((MurmelFunction)(args -> { argCheck(loc, 2, args.length);  return ((java.util.List)args[0]).toArray(requireNotNull(args[1])); }));
       ^
    method Collection.toArray(Object[]) is not applicable
      (argument mismatch; Object cannot be converted to Object[])
    method List.toArray(Object[]) is not applicable
      (argument mismatch; Object cannot be converted to Object[])

-> sollte abgefangen werden, Object... für eine nicht-varargs Javamethode sollte ein fehler sein
-> classByName erweitern um "Object[]" usw., jeweils mit argconvertern, die ein passendes array liefern

JFFI: wie soll man variadic methods aufrufen, z.B.
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;") 1) -> #(1)
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;")) -> Error: asList: expected one argument but no argument was given
-> ((jmethod "java.util.Arrays" "asList" "[Ljava.lang.Object;") 1 2 3) -> Error: asList: expected one argument but got extra arg(s) nil


eigentlich sollte LambdaJSymbol ein attribut haben interned/uninterned
-> gensym sollte namen im sinne g123 vergeben, nicht #:g123
   LabmdaJSymbol.printSEx() sollte bei "escapeAtoms=true" bei uninterned "#:" voranstellen
   es sollte ein readermacro #: geben, das das folgende als uninterned symbol einliest
-> vielleicht LambdaJSymbol.wellknown missbrauchen: statt WellknownSymbol.none -> interned und notinterned
-> gensym brauchts eigentlich nicht in Murmel, kann man mit make-symbol implementieren
-> gensym: optionalen string parameter für den namen, default ist "gensym"


welche readermacros soll der lispreader (stdin) haben/ auflösen? *features*?
-> sbcl macht/ hat anscheinend alles


MurmelJavaProgram: symboltabelle + reader + featuresEnvEntry könnten evtl. lazy instanziert werden
- brauchts für IO und/ oder eval
- und make-array
- und symbole, z.b. returnvalue von defun (was meist ignoriert wird)


dass MurmelJavaProgram immer einen interpreter instanziert, auch wenn kein eval benutzt wird, ist nicht schön
-> abgesehen von eval und zum aufrufen von Closures brauchts den interpreter für:
   compilerprimitives, die LambdaJ instanz methoden aufrufen, also solche, die ihrerseits LambdaJ member brauchen. das sind:
   - IO wegen LambdaJ.lispReader/ lispWriter, GFX wegen current_frame
   - makeArray weil das benutzt sBit, sCharacter
   (- gensym weil das benutzt den gensymCounter
     -> gensymcounter streichen 
     -> oder: Murmel hat nur make-symbol, gensym (mit oder ohne zähler) in mlib)
   (- functionp weil der interpreter würde ggf. oldLambda checken -> der compiler braucht das nicht -> static functionp OHNE haveOldLambda)
   (- getDecodedTime benutzt das zählende cons was für den compiler eh falsch ist)
   
   und interne funktionen
   - MurmelJavaProgram.intern() delegiert zu LambdaJ.intern() und das braucht LambdaJ.symtab

   *command-line-argument-list* und *features* werden beim instanzieren dupliziert
   -> weitere änderungen gehen verschütt, bzw. (setq *features*... gibt überhaupt compile fehler

-> vielleicht den "Runtime-state" nicht überall verstreuen und teilweise zwischen interpreter und MurmelJavaProgram duplizieren/ hintri-firi kopieren
   sondern eine neue klasse RuntimeState. diese klasse könnte auch logik enthalten, dass interpreter und MurmelJavaProgram schreiben/ lesen können. evtl. auch values?!?

-> oder: alle rt funktionen in LambdaJ auf static umstellen, jeweils die bisherigen memberzugriffe durch parameter ablösen
   im interpreter geben die WellknownSymbol.apply() funktionen die LambdaJmember mit, in MurmelJavaProgram geben die jeweiligen funktionen (neue) member von MurmelJavaProgram mit
   für eval in kompilierten programmen wird ein interpreter lazy erzeugt (mit symtab und compiledProgram), und der runtimestate (reader, printer, currentFrame, symtab, features) wird vor eval hin- und nach eval zurückkopiert
   -> die cons-zählerei des interpreters bleibt noch offen
      wenn auch das erledigt ist, sind alle lisplike funktionen in LambdaJ static und könnten in eine andere (utility) klasse geschoben werden


JMurmel> (eval '(values 1 2 3))
 -> 1
 -> 2
 -> 3
JMurmel> :r
==> 1
JMurmel>


JMurmel> (define f (eval '(lambda () (values 1 2 3))))
==> f
JMurmel> (multiple-value-bind (a b c) (f) (list a b c))
==> (1 2 3)
JMurmel> :r
==> (1 nil nil)
JMurmel>


values werden in kompiliertem code nicht/ zu spät genullt:
JMurmel> (values 1 2 3)
 -> 1
 -> 2
 -> 3
JMurmel> 1
==> 1
JMurmel> :r
 -> 1
 -> 2
 -> 3
JMurmel>


zusammenspiel compiler/interpreter bzgl. values reparieren, und *features*

mlib: (cons nil nil) -> (cons () ())
-> dann liefert der reader gleich null, kein symbol lookup


mlib: man kann erst die macros definieren und dann die funktionen mittels der macros:
JMurmel> (defmacro caar (lst)  `(car (car ,lst)))
==> caar
JMurmel> (defun caar (lst) (caar lst))
==> caar
JMurmel> caar


statt überall "throw new LambdaJError(..."
-> funktionen errorArgcount(), errorMalformed(), errorInternal(), usw. einführen, erstmal werfen die eine exception
-> ggf. später statt exception optional einen handler aufrufen -> condition system
  -> solange exceptions geworfen werden, können die funktionen vom interpreter, compiler, compiler rt und generiertem code benutzt werden
     wenn handler gerufen werden, schauts anders aus 


statt try -> eine dynamische globale variable *error-handler*, initialwert ist ein debugger, neue handler werden gepusht, am ende des scope gepoppt
-> oder parameter für eval(), ein neuer handler wird in ein lambda dazugebastelt
-> muss das mit den handlern für unwind-protect/ let dynamic verbunden werden, damit die reihenfolge stimmt?

funktion (error . args) ähnlich wie scheme: schreibt alle argumente mit (write arg nil) und dann (fatal)
-> eher was für mlib


errorhandling in CL ist eigentlich conditionhandling https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node338.html
geht mit handler-bind und/ oder handler-case (und ignore-errors aber das ist schiach, eher weglassen)
-> oder statt (ignore-errors form*) => result*: (try function . errorobj-or-handler)
   -> errorobj-or-handler könnte optional eine funktion sein:
      ists eine funktion dann wird die im fehlerfall mit der exception aufgerufen
      ists ein anderes objekt dann ist der returnwert von try im fehlerfall (values errorobj exception)
      -> fürs erste nur errorobj, unterstützung von handler kann später nachkommen
      -> irgendwann wird handler auch aktive restarts (und der debugger das environment) brauchen
-> zumindest typep sollte es geben, dann kann man zumindest checken, um welche exception es sich handelt
   oder type-of in Murmel?
   -> type-of ist nicht sooo nützlich, weil das berücksichtigt die subtype beziehungen nicht
   -> typep kann eigentlich die ganzen bisherigen typprädikate ersetzen wie null, atom, usw

handler-bind ({(typespec handler)}*) {form}*
  typespec muss eine vordefinierte oder benutzerdefinierte condition sein
  handler muss eine funktion mit einem parameter sein, und zwar die aufgetretene condition

handler-case expression {(typespec ([var]) {form}*)}*
  z.B.:
  (handler-case (/ 1 zero)
                (division-by-zero (dz) (princ "caught /0: ") (write dz))
                (error (c) (princ "caught error: ") (write c)))
handler-case ist eigentlich gleich wie try/catch von Java, ausser dass handler-case den handler vor dem stackabbau laufen lässt,
was aber eigentlich nur eine rolle spielt, wenn kein handler gesetzt ist und der debugger aufgerufen wird
-> nein, bei restarts spielts auch eine rolle: restarts könnten weg sein, wenn der stack bis zum condition handler zurückgerollt wird

handler-case hat auch eine no-error clause, scheint aber nicht sehr sinnvoll
  z.B.:
  * (handler-case (values 1 2 3)
                  (division-by-zero (dz) (princ "caught /0: ") (write dz))
                  (error (c) (princ "caught error: ") (write c))
                  (:no-error (a b c) (princ "no error: ") (write a) (write b) (write c)))
  no error: 123
  3
-> die anzahl parameter in der lambdalist der no-error-clause muss exakt mit der anzahl values uebereinstimmen, sonst gibts fehler

-> der compiler sollte wsl try/catch ausspucken
-> error sollte auch von mlib nach Murmel wandern:
   erster parameter ist string oder symbol, weitere parameter sind entweder argumente für den format string, oder argumente für die condition
   ist der erste parameter ein string: es gibt eine condition vom typ simple-error, msg ist formatstring+argumente
   ist der erste parameter ein symbol: das symbol muss eine condition sein
-> condition hierarchie, siehe auch CLtL2 "29.5. Predefined Condition Types" https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node346.html
   wsl. nur den subtree "error" umsetzen


sbcl hat parse-error extends error, Murmel hat SExpressionReader.ParseError extends LambdaJError was eigentlich äquivalent ist
-> CL reader-error erbt blöderweise von stream-error UND parse-error, Murmel reader-error nur von stream-error
-> ParseError nicht mehr automatisch in ReaderError wrappen
   überlegen/ checken ob/ wo der reader ParseError oder ReaderError werfen soll
-> ParseError in typep und error einbauen

funktionen zum werfen von conditions: signal, break, cerror, error

siehe auch CLtL2 "29. Conditions" https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node312.html

condition-handler sollte nicht genullt sondern auf den vorigen wert gesetzt werden (let dynamic)


(read-from-string str        [error-obj [start [end]]]) -> result, position
(read-all-lines filenamestr  [error-obj [charset]]) -> result-string-vector
(write-lines filenamestr string-vector  [appendp [error-obj [charset]]]) -> nil

(read-string  filenamestr [charset])                   -> result-string
(write-string filenamestr string  [appendp [charset]]) -> nil

jmethod sollte auch den ersten parameter "this" konvertieren

LambdaJError sollte NICHT "Error: " voranstellen, repl sollte bei Exceptions "Error: " und auch die klasse ausgeben
-> oder besser: getMessage() ohne Murmelstack, getErrormessage() mit

IndexOutOfBoundsException sollte ins Murmel typsystem integriert werden, ggf. bestehende primitives umbauen?
sbcl: (SCHAR "123" 4)
-> SB-INT:INVALID-ARRAY-INDEX-ERROR, TYPE-ERROR, ERROR, SERIOUS-CONDITION, CONDITION,

read-from-string: bounds checks hübscher machen


sollten requireString/ requireStringOrNull/ requireCharSequence auch character/ symbol akzeptieren?
-> was ist mit anderen typen "toString"?
-> write-to-string in Murmel einbauen

vielleicht doch ein macro "yielding"? basierend auf generator.lisp (?) oder im macro "yielding" eine CPS machen?
-> yielding liefert einen generator, d.h. funktion ohne parameter, primary + secondary value
-> "let dynamic" ist verboten
-> eine allfällige exception wird gespeichert und rethrow, weitere aufrufe des generator werfen wieder die gespeicherte exception


checken ob let dynamic interpretiert und kompiliert gleich ist:

(define *g* 1)
(define *g-getter* (let dynamic ((*g* 2))
                     (lambda () *g*)))
(*g-getter*) ; ==> interpreter: 1 - ok, compiler: 2 - nicht ok. sollte eigentlich test geben?!?
-> compiler sollte wsl globals bei let dynamic NICHT ins extenv stecken?!?


schreibemethoden vergleichen, ggf. parameter angleichen
-> ggf. write-string   -> write-textfile
        read-string    -> read-textfile
        write-lines    -> write-textfile-lines
        read-all-lines -> read-textfile-lines
   (weil write-string gibts in CL, hat andere parameter reihenfolge)

read-from-string   (read-from-string str [eof-obj [start [end]]]) -> object, position
-> CL              (read-from-string str &optional eof-error-p eof-value &key start end preserve-whitespace) -> object, position

write-to-string    (write-to-string obj print-escape-p?) -> result-string
-> CL              (write-to-string object &key array base case circle escape gensym length level lines miser-width pprint-dispatch pretty radix readably right-margin) -> string
                   (prin1-to-string object) => string
                   (princ-to-string object) => string

read-all-lines     (read-all-lines filenamestr [charset]) -> result-string-vector
-> CL              (uiop:read-file-lines fname) -> result-string-list

write-lines        (write-lines filenamestr string-sequence  [appendp [charset]]) -> nil

read-string        (read-string filenamestr [charset]) -> result-string
-> CL              (uiop:read-file-string fname) -> result-string

write-string       (write-string filenamestr string [appendp [charset]]) -> nil
-> CL              (write-string string &optional output-stream &key start end) => string


checken ob in kompiliertem code values früh genug genullt wird
JMurmel> (write (hashref (hash) 1))
nil
 -> nil
 -> nil
-> ist im interpreter UND compiler falsch
   interpreter und compiler resetten values zwischen forms, aber nicht bei nested forms





vector ist ein 1-dimensionales array, strings sind 1-dimensionale array von character, hash-tables sind "assoziative arrays"
welche gemeinsamen eigenschaften haben list, vector/array, string, hash-table?
-> elementzugriff
   (aref    array         0)     -> element mit index 0
   (svref   simple-vector 0)     -> element mit index 0
   (sbit    simple-bit-vector 0) -> bit mit index 0
   (char    string        0)     -> character mit index 0
   (schar   simple-string 0)     -> character mit index 0

   (elt     sequence      0)     -> element mit index 0, (elt nil 0) gibt fehler, (nth 0 nil) geht - gibt nil

   (gethash 0 hash-table)        -> element mit key 0
   (nth     0 list)              -> element mit "index" 0

-> iteration
   mapcar&co, dolist geht nur für lists
   map, reduce geht für list, vector/array, string



vielleicht beginnen mit #() und #H() lesen und schreiben, plus svref und gethash?
-> emitQuoted sollte das auch als konstanten rausschreiben (ggf. endlich alle konstanten immutable machen? und keinen listbuilder sondern ein arrayslice?)
-> und dann schrittweise den rest dazu


vielleicht doch schon mal vector und svref implementieren? vector liefert eindimensionale arrays, 0-basiert, typ T. make-array könnte später kommen, das kann viel mehr
SBCL> (atom #(1 2 3)) ; -> t
svref ist auch ein setf accessor
-> und char/ schar wären accessoren für strings...
   -> char kamma machen, setf/ schar geht nicht weil strings sind immutable
      -> vielleicht von String auf StringBuilder umstellen?
         -> oder auf ropes?
vielleicht auch list->svector und svector->list

svref, (aref), arrayp, vectorp, simple-vector-p

strings sind ein array, vector, aber kein simple-vector
-> wenns nur svref gibt aber kein aref, gibts kein "(setf (aref" problem mit strings. (s)char kamma machen, in murmel macht nth aber dasselbe, schreiben würde laufzeitfehler geben, weil strings sind immutable
-> wsl kann man ewig bei svref bleiben, dann hat murmel nur simple vector == eindimensionale arrays mit anfang=0, so wie Java
-> intern sollte es wsl arrays und arraylist geben, adjustable wär also sinnvoll, element-type irgendwann auch


-> und make-hash-table, hash-table-p, hash-table-count, clrhash, gethash, remhash, maphash, (puthash, , #H(...)), mlib: (setf (gethash...
   erweiterungen nach alexandria: (hash-table-plist hash) -> plist, (plist-hash-table plist) -> hash
   oder                           (hash-table->plist hash) -> plist, (plist->hash-table plist) -> hash
-> (hash-table-p obj) ... instanceof Map
   (make-hash-table eq [size])     ... new IdentityHashMap()
   (make-hash-table t [size])      ... new HashMap()

   (make-hash-table eql [size])    ... new EqlMap()    -> put is ueberschrieben und wrapped bei Murmeltypen den Key
   (make-hash-table equal [size])  ... new EqualMap()  -> put is ueberschrieben und wrapped bei Murmeltypen den Key
   (make-hash-table equalp [size]) ... new EqualpMap() -> put is ueberschrieben und wrapped bei Murmeltypen den Key

http://clhs.lisp.se/Body/f_mk_has.htm
    make-hash-table &key test size rehash-size rehash-threshold => hash-table
Creates and returns a new hash table.
sbcl hat u.a. ein zusätzliches keyword arg :weakness, damit kann man weakhashmaps erzeugen

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_hash-table-p.html
    hash-table-p object => generalized-boolean
Returns true if object is of type hash-table; otherwise, returns false.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_hash-table-count.html
    hash-table-count hash-table => count
Returns the number of entries in the hash-table. If hash-table has just been created or newly cleared (see clrhash) the entry count is 0.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_clrhash.html
    clrhash hash-table => hash-table
Removes all entries from hash-table, and then returns that empty hash table.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/acc_gethash.html
    gethash key hash-table &optional default => value, present-p
Value is the object in hash-table whose key is the same as key under the hash-table's equivalence test. If there is no such entry, value is the default.
Present-p is true if an entry is found; otherwise, it is false.
setf may be used with gethash to modify the value associated with a given key, or to add a new entry.
When a gethash form is used as a setf place, any default which is supplied is evaluated according to normal left-to-right evaluation rules, but its value is ignored.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_remhash.html
    remhash key hash-table => generalized-boolean
Removes the entry for key in hash-table, if any. Returns true if there was such an entry, or false otherwise.

http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/fun_maphash.html
    maphash function hash-table => nil
Iterates over all entries in the hash-table. For each entry, the function is called with two arguments--the key and the value of that entry.
The consequences are unspecified if any attempt is made to add or remove an entry from the hash-table while a maphash is in progress,
with two exceptions: the function can use can use setf of gethash to change the value part of the entry currently being processed, or it can use remhash to remove that entry.

mögliche erweiterungen
puthash gibts nicht offiziell, wird man aber wohl für (setf (gethash... brauchen.
SBCL:
* (macroexpand-1 '(setf (gethash 'key h) 'value))
(LET* ((#:HASHTABLE H) (#:NEW1 'VALUE))
  (SB-KERNEL:%PUTHASH 'KEY #:HASHTABLE #:NEW1))

eine funktion, die hashtables aus werten erzeugt, so wie list lists erzeugt, oder vector, gibts offiziell nicht. denkbar wäre
    (hash-table key1 value1 key2 value2...) => hash-hable
und/ oder
    (hash-table plist)
und/ oder
    (hash-table alist)
alexandria https://alexandria.common-lisp.dev/draft/alexandria.html#Hash-Tables hat einige zusätze für hashtables, u.a.
  Function: hash-table-plist table
    Returns a property list containing the keys and values of hash table table.
  Function: plist-hash-table plist &rest hash-table-initargs
    Returns a hash table containing the keys and values of the property list plist. Hash table is initialized using the hash-table-initargs.


spezielle read/write funktionalität scheint in CL nicht vorgesehen, in allen beispielen steht z.B.
    (setq table (make-hash-table)) =>  #<HASH-TABLE EQL 0/120 32304110>
    in CL würde man ggf. readtime evaluation verwenden, siehe https://stackoverflow.com/questions/10706024/common-lisp-shorthand-to-initialize-a-hash-table-with-many-entries
denkbar wäre #H(key1 value1 key2 value2...), könnte der murmel reader mittels plist-hash-table umsetzen, und der printer mittels alexandria:hash-table-plist
Serapeum hat dict und erweitert den printer:
    CL-USER> (toggle-pretty-print-hash-table)
    T
    CL-USER> (dict :a 1 :b 2 :c 3)
    (dict
      :A 1
      :B 2
      :C 3
     )
    which is a representation that can be read back in.
Das wiedereinlesen ist aber wsl. nicht dasselbe wie ein readermacro, der reader list halt einen aufruf von dict, der dann irgendwann wirklich passiert

equal von mlib nach murmel schieben, damit man hashmaps mit strings machen kann #H(equal "eins" 1 "zwei" 2)


define (aka globales environment) könnte ein eigenes feature flag bekommen statt mit EXTRA zusammen
-> --min++ könnte sein:
   --min+
   --io
   --define
-> oder lambda++
-> jedenfalls sollten IO und define wsl erst viel "später" abgedreht werden, apply vielleicht auch


#5(1 2 3) gibt einen vector der länge 5, es wird ggf. mit dem letzten element aufgefüllt
#5*01: bitvector, sonst w.o.

3rd party lizenzen in einen ordner, in die zips dazupacken


CL hat write-to-string, princ-to-string, prin1-to-string
-> intern und concatenate wär auch schön
   -> string-join mit leerem delimiter geht auch statt concatenate

einige CL funktionen akzeptieren "string-designator", das ist string oder symbol oder character
-> in CL gibts string: 
   Coerces X into a string. If X is a string, X is returned. If X is a
   symbol, its name is returned. If X is a character then a one element
   string containing that character is returned. If X cannot be coerced
   into a string, an error occurs.
   -> und zwar: simple-type-error ... is not a string designator
-> string zusätzlich zu write-to-string einbauen?
   -> aber "string" ist anders als list, vector, hash, ... kein "constructor" obwohls der name nahelegt
   -> string sollte wsl. java.lang.String -> char[] (aka simple-string) wandeln, d.h. mutable strings liefern
      praktisch für z.B. string-split und string-join die derzeit immutable strings liefern


kompiliertes macroexpand-1 veträgt sich irgendwie nicht mit gensym: "#:gensym" vs. "gensym"

JMurmel> (load "mlib")

==> nil
JMurmel> (macroexpand-1 '(dotimes (i 10) (write i)))

 -> (let ((i 0) (#:gensym 10)) (if (<= #:gensym 0) (progn) (if (>= i #:gensym) (progn) (let #:gensym nil (write i) (incf i) (if (>= i #:gensym) (progn) (#:gensym))))))
 -> t
JMurmel> :r

 -> (let ((i 0) (gensym 10)) (if (<= gensym 0) (progn) (if (>= i gensym) (progn) (let gensym nil (write i) (incf i) (if (>= i gensym) (progn) (gensym))))))
 -> t



Scheme r7rs sagt:
A quasiquote expression may return either newly allocated,
mutable objects or literal structure for any structure that
is constructed at run time during the evaluation of the
expression. Portions that do not need to be rebuilt are
always literal.

JMurmel> (defun foo () `((1 2)))
==> foo
JMurmel> (eq (car (foo)) (car (foo)))
==> nil
-> das sollte/ könnte t sein

JMurmel> (read) `((1 2))
==> (list (list (quote 1) (quote 2)))
sollte/ könnte aber z.B. (list '(1 2)) sein

Soll:
JMurmel> (read) (let ((a 3)) `((1 2) ,a ,4 ,'five 6))
==> (let ((a 3)) (list* (quote (1 2)) a 4 (quote five) (quote (6))))

JMurmel> `(((1 2 3) (11 22 33)))
==> (((1 2 3) (11 22 33)))


In vectors sollte auch expandiert werden (beispiel aus r7rs mit sbcl):
* `#(10 5 ,(sqrt 4) ,@(map 'list #'sqrt '(16 9)) 8)
#(10 5 2.0 4.0 3.0 8)


JMurmel> (read) (let ((a 11)) `(1 2 3 ,a))
==> (let ((a 11)) (append (quote (1)) (append (quote (2)) (append (quote (3)) (cons a nil)))))
sollte (list 1 2 3 a) geben



unquote-splice in hash (und wsl auch vector) geht nicht richtig:
JMurmel> (read) `#H(eql ,@l)
Error: program-error - hash: malformed hash: last key/value pair is missing 'value'
-> wsl. muss qq_expand iwie in readerMacro eingebaut werden, oder # und #H müssen ebenso wie ' in readObject verschoben werden
   jedenfalls muss qq_expand gemacht werden bevor vector/ hash gebastelt wird
-> `#H(,tst 1 11 2 22) wird wsl


get-internal-cpu-time gibts in CL nicht
-> wegputzen
-> "get-internal-run-time" sollte getCurrentThreadCpuTime() rufen (getCurrentThreadUserTime() liefert -1 in GraalVM)


compare könnte char[] und CharSequence gesondert behandeln statt immer String kopien zu ziehen

read-from-string ignoriert features:
  (read-from-string "#+murmel 1 2) ; -> 2, sollte 1 sein
read-from-string hat seine eigene symboltabelle:
  (eq 'x (read-from-string "x")) ; nil, sollte t sein

commandLineArgumentList umstellen auf CompilerGlobal, dann ists auch im compiler mutable
und in afterEval zurückkopieren

load als nicht-toplevel form kann compilerfehler geben:
1.lisp: 1 2 3
(if t (load "1.lisp"))
->
    // toplevel forms
    protected Object runbody() throws Exception {
        values = null;
        loc = "line 2:1..2:16: (if t (load \"1\"))";
        return (true
        ? (1L2L3L)
        : (Object)null);
    }
}



jmurmel + jrunscript dokumentieren: https://docs.oracle.com/en/java/javase/19/docs/specs/man/jrunscript.html
$ jrunscript -cp jmurmel.jar -l jmurmel -f ../../samples.murmel/fizzbuzz.lisp
1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, Fizz Buzz, 16, 17, Fizz, 19, Buzz, Fizz,
22, 23, Fizz, Buzz, 26, Fizz, 28, 29, Fizz Buzz, 31, 32, Fizz, 34, Buzz, Fizz, 37, 38, Fizz, Buzz, 41,
Fizz, 43, 44, Fizz Buzz, 46, 47, Fizz, 49, Buzz, Fizz, 52, 53, Fizz, Buzz, 56, Fizz, 58, 59, Fizz Buzz,
61, 62, Fizz, 64, Buzz, Fizz, 67, 68, Fizz, Buzz, 71, Fizz, 73, 74, Fizz Buzz, 76, 77, Fizz, 79, Buzz,
Fizz, 82, 83, Fizz, Buzz, 86, Fizz, 88, 89, Fizz Buzz, 91, 92, Fizz, 94, Buzz, Fizz, 97, 98, Fizz, Buzz


(let nil ...) und (let* nil ...) koennten/ sollten in progn verwandelt werden



compiler: (einige) forms die nicht in der tailposition sind (isLast == false) kann man eigentlich mit { forms... } schreiben, ergebnis wird ja nicht benötigt?!?
-> geht nicht innerhalb ?:, weil das braucht eine expression
-> emitForm müsste wohl einen parameter "expr" bekommen und geeignet durchreichen
   -> und bei expr == false müsste (if...) als Java if statt ?: emitted werden, und (cond...) als elsif kette statt ?: kette
   -> eigentlich sollte isLast genügen: isLast == true -> expression ist erforderlich, isLast == false -> keine expression
      -> braucht aber auch noch einen umbau von emitForms, weil das schreibt immer ignored = ...

compiler: wenn rsfx==0 ist, ist die form toplevel oder toplevel in einem defun, und die form wird in "ignoredN = <form>;" reingeschrieben
-> if, let&Co könnten da anders, einfacher rausgeschrieben werden



emitStmt() "optimiert" einiges an dead code weg
-> note/ warnung ausgeben

parsing day01.lisp...
; Note - day01.lisp:7:13..7:31: using reflection at runtime
; Note - day01.lisp:7:13..7:31: using reflection at runtime
-> sollte eig nicht sein ?!


jm samples.murmel-mlib\aoc2022\day01.lisp
-> gibt korrekt file not found
-> mit --run gibts rt error


wenn commandline options 2x gegeben werden, sagt die fehlermeldung "unknown..."
-> "unknown or duplicate" ?


GraalVM scheint murmeldir anders aufzulösen:
Error: reader-error - require: error reading file 'mlib': /home/runner/work/jmurmel/jmurmel/lambda/target/mlib.lisp
error occurred in 00_tak_apo.lisp:4:10..4:24: (require "mlib")
-> wenn mlib.lisp als resource mitverpackt würde und load auch ressourcen findet, wär das wuascht
-> wsl. wg. "--initialize-at-build-time=io.github.jmurmel"


commandline parameter --eval
-> --eval ist der letzte parameter, alles danach wird als Murmel abgearbeitet


eval: die (grosse) finally clause steht im bytecode nach jedem return
-> statt return -> break tailcall und nach der whileschleife 1x return result

labels forms wo mehr als ein name ein gensym ist gibt wsl. javacompilerfehler


https://justine.lol/sectorlisp2/ hat eine rekursionsoptimierung (oder nur tailcalls?) für dynamic lambdas:
function Peel(x, a) {
  return a && x == Car(Car(a)) ? Cdr(a) : a;
}

function Pairlis(x, y, a) {
  return x ? Cons(Cons(Car(x), Car(y)),
                  Pairlis(Cdr(x), Cdr(y),
                          Peel(Car(x), a))) : a;
}


dovector macht in jedem schleifendurchlauf ein "let"


gscheite lisp-implementation-type und lisp-implementation-version primitives
-> oder mlib?
-> mlib könnte auch was nach *features* pushen


JMurmel> (if (values 1 2 3) 'ja)
 -> 1
 -> 2
 -> 3
-> sollte JA liefern
-> weder interpreter noch compiler putzen values nach der if bedingung

weitere tests:
(cond ((values 1 2 3) 'ja))        -> geht
(cond ((null (values 1 2 3)) 'ja)) -> geht nur im interpreter


operator: inverten, umstellen auf stmtExpression (nur true bei primitives die in eine Java stmt expression konvertiert werden)

funcall hat finally und viele exits -> 306 bytes


"        private final MurmelFunction " gibts 3x: in defunToJava, emitNamedLetBody und emitLocalFunc
-> methode für den kopf rausziehen (parameter: name, rsfx und ggf emitThis)
-> "        public final Object apply(Object..." gibts überhaupt 5x


emitForms sollte ggf. nur für toplevel forms verwendet werden (ggf. umbenamsen auf emitToplevelForms)
-> überall sonst auf emitStmts umstellen
   -> emitStmt könnte statt void ein allfälliges looplabel liefern, oder tupel looplabel/nargs, emitStmts merkt sich das und übergibt das beim nächsten schleifendurchlauf wieder an emitStmt
   -> auch in defunToJava das funktions symbol durchreichen für selbstrekursive tailcalls (ist wsl einfacher als loops!)
      und labels, ggf. auch für die bindingforms falls eine lambdaform letbound ist


mlib: last0, last1, lastn umbenamsen nach "m%...", macros und funktionen


values sollte auch ein place für setf sein: (setf (values <place1> .... <placen>) <value-producing-form>), siehe http://clhs.lisp.se/Issues/iss311_w.htm
-> (setf (values g1 g2 g3) (values 1 2 3))

* (macroexpand '(setf (values g1 g2) (values 1 2)))
(MULTIPLE-VALUE-CALL
    #'(LAMBDA (&OPTIONAL #:NEW1 #:NEW1 &REST #:IGNORE)
        (DECLARE (IGNORE #:IGNORE))
        (VALUES (SETQ G1 #:NEW1) (SETQ G2 #:NEW1)))
  (VALUES 1 2))

setf (car x) usw. sollten in setf behandelt werden, nicht an get-setf-expansion delegiert, weil das sollte ohne let-forms gehen:

JMurmel> (pprint (macroexpand-1 '(setf (values (cadr a) (cadr b) (cadr c)) (values 1 2 3))))

(multiple-value-call
   (lambda (#:gensym #:gensym #:gensym)
      (values
         (let* ((#:read-var (cdr a)))
            (multiple-value-bind
               (#:store-var)
               #:gensym
               (m%rplaca #:read-var #:store-var)))
         (let* ((#:read-var (cdr b)))
            (multiple-value-bind
               (#:store-var)
               #:gensym
               (m%rplaca #:read-var #:store-var)))
         (let* ((#:read-var (cdr c)))
            (multiple-value-bind
               (#:store-var)
               #:gensym
               (m%rplaca #:read-var #:store-var)))))
   (values 1 2 3))
==> t


apply als wellknown symbol, dann fallen einige intern("apply") im compiler weg

psetf: values-places gehen nur bei einem pair weil dann ist psetf==setf

LambdaJ.currentSource wird nicht von allen embedded APIs gesetzt/ genutzt, siehe GabrielBenchmark

defunToJava könnte einen member vom compiler mit funktionsnamen belegen, das könnte für die named-let-lambdas verwendet werden

emitStmt sollte multiple-value-bind auch behandeln: in mlib scan-multiple gibts "(multiple-value-bind ... (loop (cdr x)" und das wird zu tailcall() statt continue



der interpreter spuckt eine error zeile aus bei "try"

JMurmel> (try (error "oje"))

 -> nil
 -> simple-error - oje
error occurred in line 1:6..1:18: (error "oje")

-> schaut blöd aus passt aber: die error zeile ist teil der exception message. der interpreter hat zeileninfo, der compiler nicht.
-> ggf. sollte der compiler auch zeileninfo liefern


dass die location in der exceptionmessage dranhängt ist ein hack
-> gesondertes feld
-> printSex escape=nil sollte nur message liefern, printSex escape=true sollte alles wie gehabt aneinanderhängen
   -> LambdaJError sollte Writeable implementieren


emitSetq schreibt beim letzten assignment immer clrValues
-> isDefOrLet streichen, berechnung von isStmtExpr rausziehen und in emitSetq nutzen


let-over-lambda (non-toplevel defuns) im compiler könnt so gehen:
toplevelFormToJava bekommt ein case für let/let*/letrec, das sucht in diesen forms (rekursiv) nach defuns und bereitet ein CompilerGlobal vor
emitForm schaut dann im pass 2 bei non-toplevel defuns im global environment nach obs das symbol gibt - wenn ja wird ein named lambda zugewiesen
-> aufpassen falls das vor der zuweisung benutzt wird
   -> sollte zumindest rt-fehler geben
-> würd wsl. nicht nur für defun sondern auch define gehen, wär ggf sinnvoll
-> zumindest multiple-value-bind wär auch gut


mlib: write-char, print, princ, terpri sollten optionale dest übernehmen 


location gibts nicht in ReaderError usw, nur im LambdaJError
"implements Writable" auch


typep und error haben beide elsif chains mit allen conditions
-> eine (oder zwei?) Identity map rausziehen, key ist LambdaJSymbol, value ist typprädikat bzw. ein lambda das die entsprechende exception erzeugt (und gleich schmeisst? eher nur erzeugen)
   erzeugt werden diese maps aus einem array { { string, pred, error }, ... }

evalString() sollte ggf. multiple-values printen


wenn Repl() nicht PrintStream stdout nimmt sondern Appendable könnte direkt ein StringBuilder oder StringBuffer als stdout übergeben werden
-> println muss man selber nachmachen
-> PrintStream macht auch jede menge flush()
   wenn man System.out übergibt bleibts zwar beim flush, bei StringBuilder wärs aber kein problem



#n= und #n# syntax ist unter "CLtL2 22.1.4. Standard Dispatching Macro Character Syntax" beschrieben,
siehe https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node191.html


mlib: subst, nsubst, ggf. subst-if/ nsubst-if sind einfach

mlib: copy-list gibts, copy-tree gibts nicht, wär einfach

toplevelFormToJava: solange nur progn/ defuns/ einfache defines (mit einfachem wert, zb nur atoms, keine symbols zulassen) vorgekommen sind, könnten die CompilerGlobals gleich zugewiesen werden
-> umweg über defun_... könnte man sich sparen
-> ggf. auch letXXX (inkl named let) zulassen wenn die bindingforms gecheckt werden ?


read-textfile und read-textfile-lines sollten zus parameter "translate-linefeed-p" bekommen, ggf. auch schreibfunktionen
read-textfile-lines sollte auch filespec == t koennen


read-textfile-lines sollte filename t können

write-textfile-lines sollte translate-lineend-p können

write-textfile und write-textfile-lines sollten filename t können

define und defun non-toplevel in let usw forms dokumentieren

formsToInterpretedProgram macht ein CallProgram, dessen konstruktor speichert nur den string weg
-> konstruktor sollte gleich zumindest read machen und nicht der string sondern die liste mit forms wird gespeichert.
   damit macroexpand auch schon vorab geht, müsste man einen durchlauf machen wo wie im compiler alle defun und defmacro forms durch eval durchgehen
   -> wär gschickt das erst nach eval-when einzubauen? oder gleich machen und aus dem compiler rausziehen?
-> oder body 1x aufrufen und in weiterer folge funktionen mit getFunction() holen und diese nutzen


MurmelProgram.setReaderPrinter überladen mit ReadSupplier/WriteConsumer statt ObjectReader/ObjectWriter

formsToJavaClass überladen mit ReadSupplier statt ObjectReader

defun könnte auch in labels body erlaubt sein


JMurmel> (labels ((l1 () 1)
                  (l2 () 2)))
==> nil
JMurmel> :java nil t

Error: error - internal error - formToJava: caught exception java.lang.NullPointerException: null
error occurred in line 1:1..2:10: (labels ((l1 nil 1) (l2 nil 2)))


ConsCell und ConsCell? in das array mit bekannten JFFI arguments aufnehmen

string als parameter für car/cdr ggf verbieten?

isStmtExpr in evalStmt nochmal ansehen: ignoredX = multiple-value-call
-> zuweisung ist unnötig


toplevel atoms (auch symbole) ausser dem letzten könnte toplevelFormToJava() (oder die schleife in formsToJavaSource?) gleich wegputzen
-> (ignorieren, nicht in bodyForms stecken, mit note())


mlib: bei z.b. decf ist die eval reihenfolge anders, siehe CLHS 5.1.3 http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_5-1-3.html
siehe auch sbcl/src/code/primordial-extensions.lisp
;; Define "exchanged subtract" So that DECF on a symbol requires no LET binding:
;;  (DECF I (EXPR)) -> (SETQ I (XSUBTRACT (EXPR) I))
;; which meets the CLHS 5.1.3 requirement to eval (EXPR) prior to reading
;; the old value of I. Formerly in 'setf' but too late to avoid full calls.
(declaim (inline xsubtract))
(defun xsubtract (a b) (- b a))
-> ist vielleicht nur relevant wenns "define-modify-macro" gibt?!


mapcan, mapcon edge cases: https://gitlab.common-lisp.net/cmucl/cmucl/-/issues/196
-> mlib machts wsl. falsch


psetf evaluiert komplexe forms in der falschen reihenfolge:

JMurmel> (macroexpand-1 '(psetf (car x) (car a) (car y) (car b) (car z) (car c)))
 -> (let (#:gensym #:gensym #:gensym) (setf #:gensym (car a)) (setf #:gensym (car b)) (setf #:gensym (car c)) (setf (car x) #:gensym) (setf (car y) #:gensym) (setf (car z) #:gensym))
 -> t

SBCL:
* (macroexpand-1 '(psetf (car x) (car a) (car y) (car b) (car z) (car c)))
(LET* ((#:X167 X)
       (#:NEW166 (CAR A))
       (#:Y169 Y)
       (#:NEW168 (CAR B))
       (#:Z171 Z)
       (#:NEW170 (CAR C)))
  (SB-KERNEL:%RPLACA #:X167 #:NEW166)
  (SB-KERNEL:%RPLACA #:Y169 #:NEW168)
  (SB-KERNEL:%RPLACA #:Z171 #:NEW170)
  NIL)
T



Roman numerals: https://stackoverflow.com/questions/19266018/converting-integer-to-roman-numeral
string int_to_roman(int a)
{
    string ans;
    string M[] = {"","M","MM","MMM"};
    string C[] = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
    string X[] = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
    string I[] = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
    ans = M[a/1000]+C[(a%1000)/100]+X[(a%100)/10]+I[(a%10)];
    return ans;
}


format: tilde newline https://www.lispworks.com/documentation/HyperSpec/Body/22_cic.htm

mit alten roman numerals gehts bis 4999:
* (format nil "~:@R" 4999)
"MMMMDCCCCLXXXXVIIII"


full form is therefore ~mincol,padchar,commachar,comma-intervalB
(format nil "~19,'0,' ,4:B" 3333)

(format nil "~19,0,' ,4:B" 3333) ;; ist eig falsch (ist es?) geht aber in Murmel

error messages vereinheitlichen:
func - msg: 'value'

sollte int-with-default negative zahlen verweigern? gibts negative format params?
-> sbcl ist picky, murmel, abcl, ecl nicht


Murmel format    -> Murmel jformat ... nimmt Java format string
                 -> jformat-locale
Neu                 Mlib format und formatter

Murmel error     -> Murmel jerror  ... (jerror datum . args) datum ist condition oder symbol (conditon-type) oder Java format string

Neu              -> Mlib error     ... (error datum . args)  datum ist condition oder symbol (conditon-type) oder Murmel format string oder formatfunktion
                                       (defun error (datum . args)
                                         (if (stringp datum) (raise 'simple-error (apply format (list* nil datum args)))
                                           (raise datum (apply format args))))

Neu: Murmel raise                  ... (raise condition-type msg) macht throw new condition-type(msg)
-> brauchts nicht, jerror kann das



JMurmel> :res
JMurmel> (load "mlib")
JMurmel> (format t "aaa~v&bbb" 0)
JMurmel> :r
JMurmel> (format t "aaa~v&bbb" 0)
-> das zweite format gibt einen fehler, irgendwas haut der compiler zsam

einfacherer reproducer:

JMurmel> (labels ((l () 1)) (defmacro m() (l)) (m))

==> 1
JMurmel> :r

==> 1
JMurmel> (m)

Error: unbound-variable - eval: 'l' is not bound
error occurred in line 1:34..1:36: (l)
error occurred in line 1:1..1:2: (m)
JMurmel>



define/ defun und defmacro sollte in labels erlaubt sein
-> define/ defun geht

toplevel labels wird in runBody() reingeneriert, folgende defuns bekommen nicht mehr die sonderbehandlung dass kein "defun_...()" nötig ist
-> toplevel labels die keinen normalen code enthalten (nur define/ defun/ defmacro/ macrolet/ labels) irgendwie aus runBody rausheben
