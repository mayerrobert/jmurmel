cheerpj 3.1 https://labs.leaningtech.com/blog/cheerpj-3.1

mlib hat subst/ nsubst, das ist für lists
-> CL hat noch subsitute/ nsubstitute, das ist für sequence
-> "replace sequence-1 sequence-2 &key start1 end1 start2 end2 => sequence-1"
   "fill sequence item &key start end => sequence" gibts auch noch

elisp hat mapconcat, serapeum auch



emitLabels könnte bei labels forms die nur atoms und defmacro enthalten die lokalen funktionen weglassen und nur den body in ein progn reingenerieren

wie gross wird eigentlich der constructor der generierten MurmelProgram, mit den vielen "public CompilerGlobal _caar = new CompilerGlobal(..."



im Online REPL schreibt "java nil t" in die JS console
-> output stream des compiler umlenken?!


defuns (und closures?) die nur ein toplevel "labels" enthalten könnte der interpreter in eine closure umwandeln die die lokalen funktionen im (closure-) environment hat
-> evalDefun und evalLambda sollten die labels form 1x verarbeiten
-> "(defun... (labels..." swappen nach "(labels... (defun..." macht dasselbe geht aber nur wenn die lokalen funktionen die defun argumente nicht benutzen, und geht nicht bei dynamic environment

http://clhs.lisp.se/Body/f_apply.htm:
"Because a function can neither detect whether it was called via apply nor whether (if so) the last argument to apply was a constant, conforming programs must neither rely on the list structure
 of a rest list to be freshly consed, nor modify that list structure."
-> compiler könnte bei varargs also doch arraySlice verwenden
   murmel-langref enthielt als compiler restriction "The list containing optional arguments cannot be used as an argument to `rplacd`."
   in 9c2fd0245275eaa176c2168ccffa53e523af43a8 aus MurmelJavaCompiler.params() ausgebaut: arraySlice -> arrayToList
   -> wieder einführen, rplaca und rplacd sollten für restargumentlist verboten sein, weil apply könnte ein listliteral übergeben und das darf nicht mutiert werden

wieso verbietet der compiler re-define/defun?


https://github.com/jOOQ/jOOR/blob/main/jOOR-java-8/src/main/java/org/joor/Compile.java hat ggf. einen gschickteren in-memory-compiler
v.a. gschickteren ClassFileManager


Python3 in Java: https://www.graalvm.org/python/, https://youtu.be/F8GoDqTtSOE?feature=shared

<dependency>
  <groupId>org.graalvm.polyglot</groupId>
  <artifactId>polyglot</artifactId> 
  <version>24.1.1</version>
</dependency>
<dependency>
  <groupId>org.graalvm.polyglot</groupId>
  <artifactId>python</artifactId> 
  <version>24.1.1</version>
  <type>pom</type>
</dependency>

import org.graalvm.polyglot.Context;

try (Context context = Context.create()) {
    context.eval("python", "print('Hello from GraalPy!')");
}

-> sample herrichten, vielleicht mit ezlib, s.u.

https://github.com/saicone/ezlib: Runtime library/dependency loader & relocator for Java in a single class, https://docs.saicone.com/ezlib



closures im compiler haben ein problem: die closure hält eine referenz auf den gesamten stackframe (das Object... array)
und damit auf alle variablen und nicht nur auf die variablen über die eigentlich geclosed wird.
-> dadurch kann der gc variablen die in keiner closure benötigt werden nicht freigeben -> speicherleck oder zumindest unnötiger speicherverbrauch 


constants, globals und per-thread globals richtig unterscheiden/ behandeln v.a. im interpreter


MethodHandles, JIT, inlining, indy:
https://jornvernee.github.io/methodhandles/2024/01/19/methodhandle-primer.html
https://github.com/forax/exotic/blob/master/src/main/java/com.github.forax.exotic/MostlyConstant.java


https://news.ycombinator.com/item?id=39815714
-> vielleicht (vector-push-front vec item) und (vector-pop-front vec)?
   -> ginge nur bei adjustable vector
   -> und/ oder (vector-add vec item pos) und (vector-delete vec pos [n-elements]) -> item
      heisst: vector-add bekommt einen zus opt parameter, vector-delete wäre neu
-> vector-delete in CL: https://news.ycombinator.com/item?id=39816525
-> sollte vector-add auch einen vector/ sequence akzeptieren? weil z.b. StringBuilder.insert() kann das
   -> nur sinnvoll wenn der elementtyp bekannt ist, sonst weiss man nicht ob die sequence das element ist das geadded werden soll  oder jedes element einzeln
-> sollten push/pop auch (adjustable?) vector akzeptieren? oder sequence-push/ sequence-pop?

deftest namedlet.8: the lifetime of i differs interpreter vs compiler


das "let" in named lets umbenamsen in nlet/nlet*/nletrec?
-> würd sich nicht mehr mit CL beissen. letrec kömmt ma lassen weil das gibts in CL nicht
-> ggf. fallen einige ifs im interpreter weg
-> könnte zu code duplication führen
-> checken wie serapeum's named let heisst: "nlet" (hat aber einschränkungen, named let* gibts nicht)
-> sbcl hat sb-impl::named-let (in primordial-extensions.lisp)
-> "n" ist normalerweise das präfix für non-consing (destructive)

do/ do* haben in CL und Murmel 1 oder mehrere result forms
dolist/ dotimes haben in CL eine result form, in Murmel 1 oder mehrere result forms
-> CL ist uneinheitlich, Murmel ein einheitliches superset
   -> ggf. Murmel umstellen dass es einheitlich nur eine result form geben darf?
   -> oder lassen. Beim portieren Murmel->CL würds halt fehler geben, muss man für CL ein progn einbauen
   -> oder ein flag "--warn-extensions" und das dann gibts ein note bei dolist/ dotimes mit mehr als 1 resultform?
      sollte dann bei allen inkompatiblen extensions warnen


die feature flags könnten ggf. "protocols" (siehe http://metamodular.com/protocol.pdf) aus/ einblenden
-> zusammenspielende typen und funktionen sind ein "protocol"

cons im interpreter incrementiert nCells immer, egal ob tracing aufgedreht ist oder nicht
-> checken ob das überhaupt bremst, ggf. mit if klammern, oder 2 factories: eine zählt, die andere nicht


vielleicht doch nochmal scheme macros ansehen? https://www.reddit.com/r/Common_Lisp/comments/1b95lj6/schemelike_macros_for_cl/
und https://www.jucs.org/jucs_16_2/embedding_hygiene_compatible_macros/jucs_16_02_0271_0295_costanza.pdf

einfacher repl in CL: https://www.cliki.net/repl


webserver in kawa mit netty + jooby: https://github.com/eatonphil/jvm-lisp-examples/blob/main/kawa/main.scm

compiler: kamma die logik für multiple-values umdrehen?
-> nicht wegputzen wenn mans nicht braucht
   -> sondern values wird nur belegt wenn ein flag true ist, und nur multiple-value-bind/ multiple-value-call (/ noch was?) setzen das auf true (und nach der values form gleich wieder auf false)
   -> was passiert im repl?
      -> toplevel beginnt mit flag = true, damit sollte der repl passen, und auch aufruf von body() aus Java heraus
         -> aber nur die letzte form


zyklen erkennen: https://coredumped.dev/2024/02/23/cycles-all-way-down/
-> list-length hat Floyd’s cycle detection, gibt aber noch Brent’s algorithm für zyklen in trees siehe https://en.wikipedia.org/wiki/Cycle_detection#Brent's_algorithm

load/ require in expandForms könnte das load/ require durch ein progn mit dem fileinhalt ersetzen
-> dann brauchts in eval nicht mehr gemacht werden, auch nicht im compiler
-> load und require sollten nil als return bekommen statt letzte form weil nil kann man in eval faken, so wie im compiler
-> vorteil wäre v.a. für formsToInterpretedProgram - mehrfache aufrufe von body brauchen das file nicht immer wieder einlesen

-> oder: CallProgram.body wird nur 1x aufgerufen, und in weiterer folge macht man getValue/ getFunction und ruft diese auf


mlib: substitute ist für sequence statt list


vielleicht doch :keywords ? nicht als parameter, nur als konstanten/ enum ähnlich, expandForm könnte das ins globale environment stecken


mlib: dotimes, dolist, dovector könnten laufvariablen mit namen "_" besonders behandeln:
die sind im body nicht gebunden, macroexpansion könnte effizienter sein
z.b. dotimes könnte bis 0 runterzählen, (dovector (_ v) ...) -> (dotimes (_ (length v)) ...), (dolist (_ lst) ...) braucht nur cdr und nullcheck aber kein car/cadr
-> vielleicht auch in let bindings _ als variablennamen zulassen? damit könnte man imperativen code (nur sideeffect) zwischen die bindings reinschummeln und braucht keine unnötigen variablen erfinden
-> elisp hat while, in mlib ist das auskommentiert, damit kamma auch auf 0 runterzählen


kamma ein lambda das sofort ausgeführt wird in ein let umwandeln? vielleicht gleich in expandForms()
-> kommt vor z.b. in destructuring-bind, destructuring-bind könnte auch ein let ausspucken, mittels pairlis
-> wird schon verwendet, u.a. in setf und psetf


CL hat (machine-type), Chez auch


Object[].class gibts, Murmel kann das. Object[][].class usw gibts auch, das kann Murmel nicht


vector (oder nur das was make-array ohne typ ausspuckt? oder sollte make-array "dynamic" als typ akzeptieren?) koennte intelligenter sein:
derzeit ists ein Object[] bzw. ArrayList<Object>
-> denkbar waere, dass beim anlegen nix allokiert wird, und wenn z.B. als erstes element ein double daherkommt wird ein double[] allokiert,
   wenn in weiterer folge ein "nicht passendes" objekt reingesteckt werden soll, müsste in ein Object[] umkopiert werden.

hashtables könnten auch intelligenz bekommen: bis 10 mappings ists kein hash sondern ein array mit linear search
-> kann halt regressions bringen wenn equals langsam ist
   -> vielleicht nur bei eq und eql weil das ist schnell


setf-functions: ggf. würds reichen in expandForm (setf func) in define/ defun/ im car einer form auf das symbol |(setf func)| umzubiegen?
-> zumindest noch apply, multiple-value-call


MIT Lisp OS hatte "resources" sowas wie arenas/ pools/ try-with-resources: https://news.ycombinator.com/threads?id=lispm&next=39134195#39080782


butlast-iterator wär einfach


vielleicht doch (simple) loop + return + psetq
-> let loop kann man durch let+loop+psetq ersetzen, let* loop durch let*+loop+psetq
-> problem wenn das return in einem Java lambda generiert werden soll. kann das sein?


compiler require könnte intelligenter sein:
-> erst nur das file in den interpreter stecken und filename merken
-> in einem zweiten durchgang jene defines/ defuns rausgenerieren die bisher undefined waren
-> aufpassen bei required files die andere files requiren


der compiler opencoded nur numeric compare operator mit 2 args
-> (= 1) wird ein call


Clojure hat counted?, liefert true für ISeq, false für Cons
Murmel könnte countedp bekommen, true für ArraySlice (und j.u.RandomAccess?, (mutable?) String/Vector/Bitvector?), und counted (wandelt ConsCell zu ArraySlice, liefert Vector unverändert)
-> oder statt countedp: random-access-p
-> conj dazu? rplaca würd bei ArraySlice gehen, rplacd nicht, ein weiteres element hintendran hängen ala conj würd auch bei ArraySlice gehen
   -> wenns conj gäbe, bräuchte man fast kein rplacd mehr, nur für dotted und circular lists
   -> ggf. könnte man mit conj/ ohne rplacd einen einfacheren GC nehmen? https://news.ycombinator.com/item?id=29630572
   -> Clojure conj hängt bei vector hintendran und bei list vornedran.
      ggf. wär besser immer hintendran zu hängen, das wär bei loops ala collect praktisch
      problem wär halt "(conj nil 123)", lösung könnte sein dass der erste parameter nicht (or vector list) aka sequence sondern (or vector cons) ist. oder (or vector cons counted) ?
      ähnliches problem: was liefert (counted nil) ? ein ArraySlice objekt ohne / mit leerem Object[]? ggf. müsste die funktion "null" erweitert werden
kann man das ins Murmel typsystem einhängen?


https://github.com/OpenHFT/Java-Runtime-Compiler hat einen in-memory filemanager zum kompilieren

module-info: https://github.com/brettwooldridge/SparseBitSet/pull/28/files

compiler: die quoted forms vielleicht nicht als member rausgenerieren sondern alle in ein array stecken?
-> z.b. murmel-test.lisp hat hunderte davon
-> max class file grösse: https://stackoverflow.com/questions/42294998/what-is-the-maximum-size-of-a-java-class-file#:~:text=class%20file%20contains%20a%20magic,is%20limited%20to%2065535%20bytes.
   64k methoden + 64k attribute, 64k max constant pool size (wsl. 64k einträge), wsl 1-2GB max sourcefile größe


compiler: statt global + define-methode
  -> CompilerGlobal bekommt abstrakte methode "init()", der compiler spuckt sowas aus:
     private CompilerGlobal xy = new CompilerGlobal() { Object init()...
  -> vorteil: halb soviele members in der generierten klasse, bzw. wäre eine vorbereitung dass Murmel globals nicht mehr member werden sondern in ein array gesteckt werden
  -> nachteil: bisher wurden CompilerGlobal objekte lazy bei der ersten benutzung instanziert, nachher würde alles beim instanzieren des MurmelJavaProgram instanziert
               nachher müsste ggf. der uninitialized check bei jedem get() gemacht werden?


feature/ featureflag ob environment() aufgerufen werden soll
-> wenns abgedreht ist brauchts "(defun car (x) (car x))" usw.
-> compiler müsste ggf. auch angepasst werden

paar funktionen die nehmen Predicate, Function, BiFunction usw. und verpacken/ liefern ein Murmel Primitive/ CompilerPrimitive
-> ggf. kann man das in WellknownSymbol verwenden dass nicht jede primitive eigene argchecks hat
   -> oder zumindest nicht jede einzelne primitive args auspacken muss
-> boolResult() gibts schon, ist aber nicht dasselbe


argcount check kamma zur expand/compile zeit machen weil die lambdalist steckt ja beim entsprechenden eintrag im environment
-> wsl. vor allem für den compiler interessant für benutzerdefinierte funktionen
-> ausser bei apply

wie/ wo kamma Class.cast(), isInstance(), isAssignableFrom() einsetzen?

alternativ/ zusätzlich zu ArraySlice wär ein DottedArraySlice denkbar

cadr & co vielleicht nach ConsCell schieben, für SExpConsCell und ArraySlice geeignet implementieren

array mit globals statt map: wenn ein Symbol in einem package ge-interned wird, bekommt das symbol einen zähler (der pro package hochgezählt wird)
-> damit findet man den arrayindex wenn man das symbol hat
-> darf man ein symbol in zwei oder mehreren packages internen?
   -> man kann ein symbol überhaupt nicht internen, nur einen string und man bekommt ein symbol
      -> es gibt aber "home package", und man kann ein symbol in ein package importieren, und shadowing import gibts auch
-> kompiliertes "intern" wär möglich, makunbound auch (cdr des environmenteintrags nullen, platz im array nullen)
   -> was macht unintern alles?

benutzt der reader rplacd?
-> ggf. könnte der reader gleich ArraySlice liefern, bissl weniger speicherverbrauch, interpreter wär ggf. schneller (wenn konsequent iterator statt for..cdr verwendet wird)


Zum aufrufen von murmel aus java: eine funktion (oder einen Builder?), die bekommt ein MurmelProgram + ein interface,
liefert einen proxy der die interface methoden am MurmelProgram delegiert
-> sollte der compiler optional eine klasse ausspucken, die ein gegebenes interface implementiert?

JMurmel (eher: MurmelJavaCompiler) in einen annotation processor verpacken? javax.annotation.processing.Filer, javax.annotation.Generated


load liest files als UTF-8
-> alte jm versionen mit verschiedenen java versionen checken, ggf. in changes dokumentieren


statt Files.newBufferedReader kann meist ReadSupplier.of(Path) verwendet werden

sample mit teapot?
https://www.reddit.com/r/ProgrammingLanguages/comments/1612opy/i_revamped_my_tree_walking_interpreter_into_a/

im compiler ist die if-optimierung sinnlos, weil das macht nur == statt !=
-> oder doch lassen weils notnot wegkuerzt? notnot koennte auch in emitTruthiness weggekuerzt werden? 

compilerprimitives enthalten value=null, codegenerator spuckt auch values=null aus
-> kamma eines der beiden wegmachen?

Clojure laesst "function calls" von maps zu


Checker framework abchecken/ einbauen: https://checkerframework.org/

mlib splitten: CL-compat rausziehen


auf BOM umstellen? https://reflectoring.io/maven-bom/
-> ein pom.xml nur mit dependency-management, ueberall als scope=import dependency


Docker images nach ghcr.io pushen, siehe https://github.com/clasp-developers/clasp/blob/main/.github/workflows/docker.yml
und https://github.blog/2020-09-01-introducing-github-container-registry/#:~:text=GitHub%20Container%20Registry%20is%20free%20for%20public%20images.&text=By%20publishing%20container%20images%20with,other%20developers%20on%20the%20team.
und https://docs.github.com/de/packages/working-with-a-github-packages-registry/working-with-the-container-registry

einfacher:
https://github.com/dnaeon/cl-jwk/blob/master/.github/workflows/docker-image.yaml
https://github.com/marketplace/actions/build-and-push-docker-images

distroless Java docker images: https://github.com/GoogleContainerTools/distroless/blob/main/examples/java/Dockerfile



GraalVM + Swing geht anscheinend doch, zumindest auf linux: https://www.praj.in/posts/2021/compiling-swing-apps-ahead-of-time/
vielleicht auch Windows: https://www.reddit.com/r/java/comments/12yiebx/graalvm_native_image_faster_smarter_leaner/jhu6vtu/


ProGuard abchecken, wsl. ohne obfuscation nur simplification: https://www.guardsquare.com/manual/home
CRaC abchecken: https://docs.azul.com/core/crac/crac-guideline
apptainer abchecken, https://apptainer.org/, ähnlich wie docker


Steele and Sussman in "The Art of the Interpreter (1978)":
Statt environment als alist
-> liste von frames, jeder frame ist ein var-list/ val-vector cons
   -> vielleicht sogar statt liste mit frames -> ArrayList mit frames?
   (Steele und Sussman hatten eine liste mit var-list/ val-list conses)
   -> neue klasse Frame mit 2 arrays: symbols und values, env ist dann eine liste mit Frame objekten
   -> evalLet, evalLabels, evalMultipleValueBind sollten statt env->extenv einfach ein Frame objekt liefern, env als parameter brauchts nicht mehr
   -> evlis, evalMultipleValuesArgs sollten eine ArrayList oder Object[] liefern
      variable argList in eval sollte statt ConsCell ArrayList oder Object[] werden
      zip brauchts überhaupt nicht mehr
      primitives sollten Object[] nehmen, gleich wie bereits im Compiler (ggf. brauchts dann nicht mehr alle primitives/ argcountcheck methoden doppelt?)
   -> lookupEnvEntry bzw. fastassq müsste angepasst werden, ggf. kann das (zumindest teilweise) 1x zur macroexpansiontime gemacht werden?
   -> bei lexikalischem environment wärs einfacher, einen frame wiederzuverwenden
   -> bei dynamischem environment wärs einfacher bei tailcalls einen frame zu droppen oder wiederzuverwenden

Mittelbar damit zusammenhängend:
Das globale environment könnte statt aus einer Map aus Object[] (oder ArrayList?) mit Werten und einer Map Symbol->Offset bestehen
-> der compiler könnte zur compilezeit bekannte offsets hardcodieren, der interpreter könnte die offsets zur macroexpansiontime auflösen
-> vielleicht getrennte globale environments compiler vs. interpreter zusammenführen?

probleme mit "runbody(): code too large"
-> ggf. sollte toplevelformtojava toplevel let/let*/progn in Murmel funktionen (oder Java methoden?) rausziehen
-> oder überhaupt:
   jede funktion und jedes toplevel letXX wird in eine toplevel klasse rausgezogen
   "defpackage" könnte eine klasse ausspucken die hat nur ein (static?) array und ggf. eine Map symbol->offset (oder symbol->CompilerGlobal),
     und ggf eine symboltable (oder brauchts die symboltable zur laufzeit gar nicht mehr?)


format: checks obs genügend argumente gibt
format: formatter checkt ob argumente zur directive int >= 0 sind, m%format-function nicht
-> noch offen: ~v@*, ~v:*, ~v*, ~vT, ~v~, ~v|, ~v%, ~v&
format könnte noch "Tilde Slash: Call Function ~/name/" unterstützen: http://www.lispworks.com/documentation/HyperSpec/Body/22_ced.htm
parameter reihenfolge: stream arg colonp at-sign-p more-params



CTRL-C aka sigint handlen/ umlenken?


immutable sequences (conses, lists, vectors)
wsl sollte man unterscheiden: darf man elemente ändern vs. darf man hinzufügen
-> sollen alle kombinationen zulässig sein?
   oder nur           mutable -> nonappendable -> immutable
   vgl. adjustablep = t       -> nil           -> 'immutable 
-> immutability ala Clojure ist was anderes. in Clojure gibts viele funktionen die das argument nicht mutieren, sondern eine kopie mit structural sharing/ copy-on-write(?) erzeugen
   könnte man ggf. zusätzlich machen: funktionen wie remove liefern bei immutable argumenten keine vollständige kopie sondern machen structural sharing

immutable vectors wären einfach:
adjustablep=nil gibt einen simple-vector, simple-vector deckt den fall ab: man darf/ kann nicht appenden, d.h. vector-add gibt fehler
adjustablep='immutable könnte einen vector erzeugen, wo vector-add und seqset fehler geben

conscells: unterscheiden ob rplaca und/ oder rplacd einen fehler werfen
-> rplacd verboten würde "adjustablep=nil" entsprechen
-> rplaca verboten würde "adjustablep='immutable entsprechen
-> hat auswirkungen zumindest auf cons, list, list*: adjustablep muss iwie in Murmel angebunden werden, dafür gibts optimierungsmöglichkeiten wie z.B.: eine liste kann als arrayslice umgesetzt werden
   ggf. (xcons adjustablep car [cdr]), (xlist adjustablep obj . more-objects*), (xlist* adjustablep obj . more-objects*)
   und/ oder eine funktion "immutable" und der compiler erkennt pattern wie "(immutable (cons a b))", oder "(immutable (append l1 l2))" wird durch was besseres ersetzt?
-> ArraySlice wäre derzeit adjustable=nil. wenns das konzept "nonappendable list" gibt, könnte die varargs-liste wieder ein ArraySlice sein, im compiler in liste umwandeln könnte man sich sparen
   wenn die vararg liste ein arrayslice wäre, würde cdr arrayslice objekte erzeugen.
   aber wsl geht man selten mehr als 1x über die liste drüber,
   d.h. alt: werden in jedem fall conscells erzeugt, neu: bei nutzung von cdr werden arrayslices erzeugt, bei cadr/ nth/ elt wird nix allokiert


sxhash sollte eine looperkennung bekommen ähnlich wie length
-> der trick von list-length geht nicht, weil sxhash muss trees können, list-length braucht das nicht
   -> nein, CL sxhash scheint trees nicht zu traversieren: https://stackoverflow.com/questions/69949627/common-lisp-sxhash-and-nested-lists
-> für sxhash ist ein zähler wsl ok
-> equal sollte ggf. eine richtige looperkennung bekommen? compare-equal auch?
   müsste aber wsl mit identityhash gemacht werden, damit loops auch in trees erkannt werden.
   -> oder mit einem flag "visited" in ConsCells, muss dann synchronized sein, muss 2x alles traversieren, am ende wieder alles auf 0 setzen
   vielleicht eigene xequal funktion (xequal o1 o2 [detectcirclep=t])
   ein problem gibts eigentlich nur, wenn beide argumente von equal circular lists und equal sind, alles andere geht und terminiert
   -> das problem tritt also auf, wenn eine circular list als key einer equal map verwendet wird (und compare-equal map?)


current_frame zw. interpreter und compiler hintri/firi kopieren?
-> current_frame, values, *features*, lispReader, lispPrinter sollten wsl. ThreadLocals sein

mlib: get-setf-expansion sollte eigentlich multiple-value liefern, nicht list

mlib: ggf. nth und nthcdr vermehrt einsetzen statt cdddr usw.,
      cXr (und ggf. print, ... weitere?) vielleicht in ein eigenes CL compatibility file auslagern?!


static initializer koennen langsam sein, siehe https://pangin.pro/posts/computation-in-static-initializer
-> startup profilern, ggf. helperklassen statt static{} sections

Primitive, CompilerPrimitive und MurmelFunction könnten alle auch
  Runnable, Comparator, Callable, Function, BiFunction, Predicate, BiPredicate, Supplier, Consumer
und ggf. weitere "Standard FunctionalInterfaces" unterstützen
-> die methode des jeweiligen interface würde als default methode implementiert, und wenn die arity der tatsächlichen methode anders ist dann krachts zur laufzeit so wie bei jproxy
-> würde die meisten jproxy aufrufe ersetzen
-> jproxy sollte wsl erkennen ob ein interface implementiert werden soll das bereits implementiert ist und dann das argument unverändert zurückgeben,
   bzw. der compiler braucht keinen code zu erzeugen
-> oder bleiben lassen, weil wenn ein verbessertes makeProxy() bekannte interfaces ohne reflection/ dynamic proxy implementiert, macht vielleicht HotSpot-inlining den rest

makeProxy/ jproxy optimieren: für ein interface mit einer einzigen methode könnte der compiler ein lambda ausspucken:
-> (jproxy "Comparator" "compare" comp)
   -> (Comparator)((a, b) -> comp.apply(a, b))
evtl. auch mehrere methoden als anonyme klasse abgeleitet von der proxyklasse?


ggf. lnwrite+print rauskicken und einheitlich zeilenumbruch am ende statt am anfang


(vector-sort vec [comparator [from [to]]]) -> sorted-vector
(list-sort lst [comparator [from [to]]])   -> sorted-list
oder seqsort?
-> (seqsort result-type seq [comparator [from [to]]])
   ist result-type != nil wird seq NICHT mutiert und es gibt eine kopie
   ist result-type == nil wird seq in-place mutiert und seq ist der return wert
-> CL hat
   sort sequence predicate &key key => sorted-sequence
   stable-sort sequence predicate &key key => sorted-sequence
-> oder sort und sorted - sort mutiert, sorted kopiert


(string-compare s1 s2) -> <0 or 0 or >0
(number-compare n1 n2) -> <0 or 0 or >0
(char-compare   c1 c2) -> <0 or 0 or >0
(predicate->comparator predicate) -> comparator
(defun predicate->comparator (predicate)
  (case predicate
        ((string<) string-compare)
        ((string>) (lambda (l r) (string-compare r l)))
        ...
        (t (lambda (l r)
             (cond ((predicate l r) -1)
                   ((predicate r l) 1)
                   (t 0))))))
XXX-compare in Murmel könnten <, >, <=, string= usw. ersetzen, < könnte in mlib implementiert werden


ggf. eine warning ausgeben, wenn lambdalist oder letXX ein global shadowed?
-> weil da ist Murmel anders als CL: CL macht ein dynamic rebind


interpreter: lokales und globales environment müssen nicht eine einzige liste sein
-> das lokale (lexikalische) environment bleibt eine liste, das globale wird eine hashmap, besser: IdentityHashMap
   symbollookup sucht erst in der liste, dann ggf. fallback in die hashmap.
-> oder das globale environment ist überhaupt ein array/ eine arraylist, symbole bekommen beim internen (oder besser von define/ defun?) einen von 0 aufsteigenden index.
   symbole für special forms bekommen keinen index, symbole für wellknown primitives oder wellknown symbols bekommen hardcodierte indizes,
   ggf. könnte so ein array auch in MurmelJavaProgram verwendet werden, statt vieler einzelner CompilerGlobal members

kompiliertes eval sieht nur das predef topenv. abhilfe wäre, ins generierte programm eine alist mit allen defines/defuns zu generieren,
und das wird eval mitgegeben.
evtl. diese alist auch in Murmel anbinden?
evtl. auch macros berücksichtigen?
-> kompiliertes macroexpand-1 könnte dann auch besser werden
-> oder array/ arraylist wie oben

environmentreferenzen inline cachen?
-> symbol on-demand durch cacheobjekt ersetzen, das cacheobjekt hat eine weak reference auf die ConsCell im environment
   (weak reference wär nicht nötig für globals, aber für parameter, und für globals falls/ sobald es makunbound gibt)
-> wenn globals ein hash oder array sind, bleiben nur mehr parameter/ locals uebrig


(read-bytefile  filenamestr)                           -> result-integer-vector (am besten signed bytes?)
(write-bytefile filenamestr integer-vector [appendp])  -> nil


macrolet/ macroexpand mit lex environment:
kamma den teil des macros, der das lex environment benutzt, wie eine inline funktion behandeln,
und nur die subtrees die kein environment nutzen zur macroexpansion time expandieren?
-> das wär dann in etwa: das macro wird in kleinere macros zerteilt, erst zur laufzeit wird bestimmt was greift
-> macroexpand-1 tests aus clhs nochmal ansehen
-> ist anscheinend viel einfacher: aus dem lex environment werden nur lokale macros ausgelesen,
   d.h. in expandForm() ein macroenvironment mit lokalen macros mitführen wär ausreichend?!?
   -> und macroexpand mit einem nullable parameter "environment" erweitern.
      ist der nonnull werden da zuerst die macros gesucht, mit fallback auf die globale hashmap
      damit könnte umgesetzt werden, dass lokale funktionen (definiert mittels labels, oder looplabel) richtig shadowen
      let-variablen die als funktion benutzt werden, sind und bleiben offen/ ein problem
      -> könnte man auch leicht einbauen: als "symbol" ins lokale macroenvironment mit reinnehmen
         -> doch ein problem, weil macro oder nicht hängt am LambdaJSymbol dran (macroclosure)
            müsste das lokale macroenvironment eine alist symbol->macroclosure werden bzw. symbol->LOCAL wenn ein macro geshadowed werden soll
            und macroexpand benutzt nur bei globalen symbolen aus der hashmap die LambdaJSymbol.macroClosure
-> (macro-function symbol lexenv) waere machbar: symbol in lexenv suchen, fallback auf "globales environment" aka LambdaJSymbol.macro

defmacro ggf. ersetzen durch set-macro-function/ macro-function, und defmacro durch ein macro in mlib ersetzen
-> vielleicht auch set-macro-symbol/ macro-symbol dazu



mlib: defsetf (kurzform) müsste einfach gehen, z.B. mit einer alist (access-fn . update-fn), oder es werden setf-funktionen on-the-fly erzeugt
-> brauchts spätestens mit benutzerdefinierten datentypen (defstruct, defclass)

(slice n seq) -> shared-subsequence + (seqset-first seq new-elem) -> new-elem
-> das wäre eine verallgemeinerung von nthcdr + m%rplaca
   könnte für einfacheres/ effizienteres get-setf-expansion verwendet werden
-> vielleicht integrieren in ein neues "defsetf mittellange form": (defsetf access-fn update-fn reffirst-fn setfirst-fn)


fatal sollte LambdaJError werfen (statt RuntimeException), checken ob das dann hübscher ausgegeben wird


so fügt man eine primitive hinzu:
WellknownSymbol durch einen neuen enum wert erweitern
-> damit kanns der interpreter
Compiler ist derzeit umständlicher:
* neue funktion
* den switch in getValue() erweitern
* das string array MurmelJavaCompiler.primitives bzw. MurmelJavaCompiler.aliasedPimitives erweitern
-> damit kanns der compiler und MurmelJavaProgram
-> plus doku: murmel-langref, murmel.completions


vielleicht doch in MurmelJavaProgram (nur intern) von t/nil auf true/false umstellen?

*command-line-argument-list* ablösen durch *argv* (plus evtl *argc*)?
-> *command-line-argument-list* könnte in mlib umgesetzt werden


im else zweig kann man nil weglassen. sollte man auch weglassen weil sonst gibts umsonst den environment lookup von nil
-> oder in expand wegoptimieren

   cond mit nur zwei zweigen: condition + t
   -> in if umwandeln, kann ggf weiter optimiert werden
      (cond ((null x) 'null)
            (t 'notnull))

      (if (null x) 'null
        'notnull)

      (if x 'notnull
        'null)


gcd gibts in BigInteger
static int lcm(int a, int b, int gcdValue) { return Math.abs(a * b) / gcdValue; }
siehe auch https://stackoverflow.com/questions/4201860/how-to-find-gcd-lcm-on-a-set-of-numbers


mangle könnte einfachere namen generieren, wenn häufige buchstaben nicht durch zahlen ersetzt werden
  -     _dash_
  %     _pc_

assq und assoc: checken ob branchless was bringt: nullcheck & car-vergleich

kompilierte defuns vielleicht anders ausspucken:
  statt define_... mit einem lambda -> java methode + zuweisung zur globalen variable inline emittieren
  dann würden zumindest für die toplevel defuns lesbare namen im JFR stehen

http://cs-www.cs.yale.edu/homes/dvm/format-stinks.html
-> macro "out" als alternative zu format

vector-ensure-capacity, vector-trim-to-size
-> fehler für simple vectors

vector-capacity: gibt length für simple vector, capacity für stringbuffer/builder
-> geht nicht weil arraylist gibt capacity nicht her
   -> geht evtl mit reflection, k.a. obs da add-opens braucht

checken was alles serializable sein sollte, Closure wsl. nicht

toplevel let/let*/letrec (nicht named) gesondert behandeln: {} block mit normalen Java variablen
-> damit würden defuns und lambdas mit nur einem toplevel letXX effizienter
-> ggf doch toplevel named letXX in einen loop kompilieren?

vielleicht loc aufteilen: String filename, int linepos int colpos, String info
-> bei (declaim (optimize (debug 0))) bleibt info leer, würde eine menge stringliterale einsparen


- vielleicht Callable, Runnable, Supplier, Consumer, ... ins Murmel Typsystem einhängen? functionp + eval + compiler-runtime

- vielleicht deque integrieren (java.util.ArrayDeque)?
  von vector erben, oder alleinstehender typ?
- splice integrieren?


mlib - scan: weitere helper

foldl, foldr, vielleicht foreach, filter

(scan-tree lst)... liefert einen generator der ein depth first traversal macht und die blaetter liefert

(scan-if generator pred)... filtern
-> oder "filter" ? oder remove-if erweitern?
   -> (filter-generator pred generator), vgl. (remove-if-not pred seq)

(map-generator func generator . more-generators)... aufeinanderfolgende calls des erzeugten generators liefern (function (generator)),
                                                    ähnlich wie map, return ist aber generator statt sequence
-> brauchts das oder ist das (multiple-value-compose function generator) ?
   -> bei multiple-value-compose muss man selber den secondary value durchreichen, und ggf. bei nil nix machen
      wär also schon gut. eine function als parameter reicht, weil (scan-mapped generator (compose f3 f2 f1)) geht auch
-> oder "transduce-generator" ?
   -> transduce könnte eine funktion value...->value,more übernehmen. damit könnte transduce die funktionen map und filter umsetzen

(flatmap-generator func generator . more-generators)
-> func übernimmt soviele parameter wie generators gegeben sind, liefert einen generator
   flatmap liefert einen generator, der die concatenation liefert

(reduce-generator func generator)
(count-generator generator)... liefert ein fixnum. oder soll length erweitert werden dass generator auch geht? oder beides? 
(collect-generator generator result-type)... materialisiert in eine liste/ vector/ bitvector/ string
-> oder (concatenate-generator result-type generator . more-generators) -> sequence, vgl CL concatenate

oder überhaupt generator ("lazy sequence") überall zulassen wo sequence erlaubt ist?
-> map, reduce, reverse (?), remove, remove-if, length könnten generators unterstützen
   -> map müsste 'generator als zus. returntyp unterstützen, filter/remove/remove-if würde bei input generator einen generator liefern
      -> terminals count/length, collect/concatenate, reduce: CL funktion kann erweitert werden dass generator als parameter zulässig ist, achtung: from-end-p bei reduce
         reverse: CL funktionen besser ohne generator support belassen, weil das geht nicht lazy, es müsste zu beginn alles materialisiert werden

oder: filter, foldl, foldr (wie Scheme): übernehmen list, vector, bitvector, string und generator
-> (foldl (lambda (l r) (cons r l) nil gen) würde eine liste ergeben
   (foldr cons nil gen) eine verkehrte liste



Clojure hat swap!, z.B. (swap! i + 3)
-> das könnte +f, -f, *f, /f usw. ersetzen. der name swap! scheint eher ungünstig. Clojure swap! scheint ausserdem atomic zu sein

Scheme hat case-lambda

primitive und compilerprimitive könnten dasselbe sein, bzw. die interpreter primitives könnten CompilerPrimitive implementieren
-> ausser: apply (und eval?)
-> aber: der interpreter hat die liste mit argumenten bereits (vom reader), das müsste bei jedem call in ein array verwandelt werden
   -> besser primitive und compilerprimitive beide beibehalten
   -> aber: der interpreter hat NICHT die liste mit argumenten, die wird von evlis erzeugt, und evlis (oder ein zusätzliches evlis) könnte auch ein array erzeugen

evalOpencode vervollständigen
-> und environment() könnte alle primitives generieren: loop über WellknownSymbol.values + argcountcheck + evalOpencode
-> evtl ALLES an die WellknownSymbols dranhängen?
   argcount min/max
   code für Primitive
   code für CompilerPrimitive: für getValue() in MurmelJavaProgram benutzen
   zuordnung name/ compiler-javaname für emitOpencode im compiler


nth, nthcdr von mlib nach murmel? wg. ArraySlice und string (?)
vielleicht make-array aus murmel rauskicken und in mlib umsetzen
-> in jmurmel nur make-simple-vector, make-simple-bitvector, ...


vielleicht die cons-zählerei rauskicken? braucht eh niemand
-> oder zumindest static zähler
-> evtl auch maxEnvLen, maxEvalStack, maxEvalLevel, oder vielleicht besser diese zähler in ein DTO stecken, das optional allokiert wird

static final members können aus system properties initialisiert werden
-> evtl. für Tracelevel LambdaJ.trace verwenden, dann würde ggf. JIT das gance tracing wegoptimieren. traceOn & traceFunc wäre ggf auch hinfällig

statt CustomEnvironmentSupplier -> builder pattern, siehe todo_dont.txt
-> CustomEnvironment bei jedem aufruf von interpretExpressions() mitzugeben ist eh fragwürdig.
   init() jedesmal aufrufen eigentlich auch, weil das ändert die members topEnv, lispStdin, lispStdout, nicht schön!



clojure hat "named lambda": (fn label [params] forms)
-> vielleicht "named lambda" in Murmel? label würd aber dasselbe machen
-> ausser: Clojure generiert für ein named lambda eine wirkliche funktion, gibt dann bessere stacktraces
   in murmel wäre ggf. der output von JMC besser lesbar (weniger anonyme funktionen). closures gibts dann aber nicht mehr gratis

beim iterieren kann man das listenende mit "endp" checken, endp sollte einen fehler werfen wenn cdr kein cons und nicht nil ist (d.h. fehler bei dotted list)
-> oder mit "atom" checken, das geht schneller, dotted lists bleiben aber unerkannt, letztes element einer dotted list bleibt unerkannt/ wird ignoriert


-> sollte kompiliertes catch und/ oder throw TCO bekommen?
-> interpreter + compiler:  (error 'control-error) falls es ein throw tag nicht gibt, braucht man wsl nicht für ein fertiges programm, aber fürs interaktive entwickeln


https://docs.oracle.com/en/java/javase/17/vm/class-data-sharing.html
-> vielleicht ein massgeschneidertes classes.jsa für das dockerimage erzeugen?


performance impact von assert: https://stackoverflow.com/questions/4624919/performance-drag-of-java-assertions-when-disabled/40919125#40919125

(let loop ((n 10)) (writeln n) (if (= n 3) (setq loop (lambda (n) (writeln (quote done))))) (loop (1- n)))
-> geht im interpreter, gibt java compile fehler im compiler (cannot assign a value to final variable _loop2)
(labels ((l () (writeln 'vorher) (setq l (lambda () (writeln 'nachher))))) (l) (l))
-> geht im interpreter, gibt java compile fehler im compiler (cannot assign a value to final variable _l2)
-> in sbcl können lokale funktionen mit setq auch nicht verändert werden (local call vs. full call), dafür fallen runtime argcount checks usw weg
-> murmel sollte setq mit loop labels und labels-lokalen funktionen verweigern, dann könnten argcount checks 1x gemacht werden, ggf. könnte der environment lookup wegfallen
   -> vielleicht sollte expandForm() ein environment mit lokalen funktionen (und primitivies?) mitführen, mit symbol->parameteranzahl tupeln.
      damit könnte zuweisung an locals (und bei speed>=1 an primitives) erkannt und verweigert werden, und argcount checks könnte 1x in expandForm() gemacht werden.
      1x argcount check wär für interpreter und compiler nützlich, und ggf. wäre auch notAPrimitive() im compiler hinfällig und/ oder interpreter und compiler würden sich gleich verhalten


(defmacro m() 1)
(eval '(m))
-> geht im interpreter, geht nicht im compiler, weil m müsste zur laufzeit aufgelöst werden

(defmacro x nil 1)
(labels ((x (y) 11))
  (x)) ; sbcl ruft die lokale funktion auf (mit fehler wg. argument), Murmel ruft das makro
-> ggf. angleichen oder mit fehler verweigern
-> macros sollten wsl auch scope bekommen

System.err vs. System.out aufräumen: repl sollte alles nach System.out schreiben, !repl sollte fehler nach System.err schreiben


eval-when endlich einbauen
siehe CLHS "Special Operator EVAL-WHEN" http://clhs.lisp.se/Body/s_eval_w.htm
siehe CLHS "3.2.3.1 Processing of Top Level Forms" http://www.lispworks.com/documentation/lw60/CLHS/Body/03_bca.htm
siehe CLtL "5.3.3. Control of Time of Evaluation" https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node68.html
-> vielleicht test dazunehmen? wie?

-> (eval-when (compile | load | compile load) forms...)
   nur toplevel, CL hat noch "eval/ :execute", das brauchts eigentlich nur für non-toplevel eval-when
-> "nur toplevel" heisst, eval-when kann auch in einem progn und/ oder einem anderen eval-toplevel drinstehen

-> (load): "not-compile-time"  (das ist das neue default)
   interpreter: enthaltene defmacro wird verarbeitet, andere forms werden verarbeitet -> so wie bisher
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden nur compiliert -> anders als bisher wird nur defmacro in den compiletime-interpreter gesteckt

   (compile load): "compile-time-too"
   interpreter: enthaltene defmacro wird verarbeitet, andere forms werden verarbeitet -> so wie bisher
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden in den interpreter gesteckt und compiliert
   -> mit (eval-when (compile load) ...) kann man das bisherige verhalten einstellen. wirds für mlib brauchen. in diesem modus steht auch im compiler alles zum macroschreiben zur verfügung

   (compile): "compile-time-only"
   interpreter: enthaltene forms werden ignoriert, ergebnis von eval-when ist nil
   compiler:    enthaltene defmacro wird verarbeitet, andere forms werden nur in den compiletime-interpreter gesteckt
   -> effektiv kann man mit diesem modus wohl compiler macros machen: die makros werden nur beim kompilieren expandiert, und die makros haben funktionen aus diesem modus zur verfügung

   ()
   interpreter: enthaltene forms werden ignoriert
   compiler: enthaltene forms werden ignoriert

-> zulässige übergänge (toplevel eval-when oder nested eval-when innerhalb progn oder eval-when)
   (compile load) "compile-time-too": wegnehmen ist erlaubt
   (load) "not-compile-time": load wegnehmen ist erlaubt (aber nicht sinnvoll), compile dazugeben ist erlaubt
   (compile): wegnehmen ist erlaubt (aber nicht sinnvoll), dazugeben wird ignoriert (oder fehler oder warning?)
   (): wegnehmen kamma nix mehr, dazugeben wird ignoriert


packed-list könnte ein ArraySlice liefern. wie list, aber weniger allokationen, nth und nthcdr wäre schnell wenns in JMurmel drin wäre, cdr würde allokieren, rplacd geht nicht



mit java.util.concurrent.locks.ReentrantLock kann man synchronized nachbasteln



evlis könnte symbole durch eine environmententry referenz ersetzen:
-> evlis schaut beim iterieren: ist es ein symbol, wenn ja sucht evlis 1x mit assq die conscell im environment, und ersetzt das symbol durch (envref enventry)
   die neue "special form" envref muss in eval eingebaut werden, und setq muss auch erweitert werden/ damit umgehen können, weil dann kann "(setq (envref enventry) value)" vorkommen
-> der ganze spass würde auch für makros gehen: evlis ersetzt einen macrocall durch die expansion
-> ggf. kann man auch lineinfo in die erzeugten conscells aus dem macro aufruf reinkopieren?

-> in evlis UND beim abarbeiten einer function application expandieren/ ersetzen
-> envref für freie variablen, paramref für parameter: paramref enthält einen offset, und gelesen wird mit (cdr (nth env offset)) oder so
   envref geht nicht für parameter weil da würden die argumente des ersten aufrufs hart verdrahtet

statt dem "opencoden" im interpreter könnte ähnlich wie tryExpand gecheckt werden, ob das car der form ein symbol das auf eine primitive zeigt. (muss aber vor evlis call passieren)
 falls ja wird das car durch ein nicht internes symbol "prim-application" ersetzt und danach die adresse der primitive reingezwickt.
 z.b. (car 1 2) -> (prim-application #<car> 1 2). "prim-application" kommt in den switch mit den special forms, ist also auch eine special form, die
 in der sprache aber nicht sichtbar ist weil nicht interned. diese neue "hidden special form" macht evlis und ruft dann die primitive auf.
 -> darf nur bei speed >= 1 gemacht werden, weil sonst könnte sich das ändern, was hinter dem jeweiligen symbol liegt (bei speed=0 können auch primitives mit setq geändert werden)
    -> ist aber doch eine änderung zu bisher, weil derzeit kann auch bei primitives ein macro davorschalten
 -> evalOpencode brauchts dann nicht mehr, und der switch in opencode fällt weg
 -> wenns einmal umgepatcht ist, werden primitive-aufrufe immer gleich im ersten switch behandelt, keine ifs, kein checken obs ein macro ist
 -> optimierung wär auch noch möglich: (cdr (cdr x)) -> (prim-application #<cddr> x) oder (prim-application #<nthcdr> 2 x), wobei #<cddr> nicht im environment drin ist, symbol dazu brauchts auch keines

evalLet() macht jedesmal ziemlich viele checks inkl HashMap und member
-> tryExpand könnte 1x checken, old style (let (a b c) ...) -> (let ((a nil) (b nil) (c nil)) ...) umschreiben, dann wär evalLet viel einfacher und schneller
-> generelles problem ist, dass tryExpand topLevel forms nicht sieht
   -> umbauen dass tryexpand nicht forms(-liste) bekommt und forms.rplaca macht, sondern die form bekommt und inplace modifiziert: car und cdr austauscht

??? ähnlich könnte man CPS on-the-fly machen: eine neue special form, die bekommt als zusätzlichen parameter die "next" funktion. nach abarbeiten der aktuellen forms gehts mit "continue tailcall"
dorthin. 

der trick mit nicht-internden symbolen müsste für "hidden special forms" aber auch für "jmurmel interne primitives" gehen.


zip einen zusätzlichen parameter "append-to" geben, damit könnte man bei tailcalls ConsCells wiederbenutzen. bei "let loop" gibts viele tailcalls, das müsste die churn rate runtersetzen
ähnliches müsste im compiler auch gehen: statt einen call mit argumenten und commas:
-> tailcall(f, reassign3(args, v1, v2, v3)) oder
   tailcall(f, reassign1(args, v1) usw.
   oder gleich tailcall3(f, args, v1, v2, v3) - wenn args zufällig die passende länge hat, wird wiederbenutzt, sonst wird ein neues array allokiert
   -> ist aber kompliziert, wsl. ist allokieren+gc schneller als diese komplizierte logik


import könnte alle public methoden einer java klasse ::-en, vielleicht ein optionales präfix als argument für import?
und/ oder eine funktion (z.B. "reflect"), die eine liste mit :: forms ausspuckt, und define erweitern dass nicht nur symbol/value sondern auch eine liste geht?
-> reflect könnte auch optional eine liste mit strings bekommen, die enthält die gewünschten methoden (statt alle)
-> vielleicht auch getter/ setter generieren für members? nur setter falls nicht final?
-> vielleicht auch MurmelProgram akzeptieren, ggf. iwie speziell behandeln? vielleicht import für MurmelProgram, reflect für normale Java klassen? oder MurmelProgram in load/ require einbauen?
-> load und require sollten auch jar files mit kompiliertem murmel können
   dazu sollte die java methode loadfile erweitert werden, die wird von allen benutzt, interpreter und compiler.
   MurmelJavaProgram könnte weitere reflection methoden bekommen (getAllFunctions(), getAllValues()=, die von loadFile
   genutzt werden können, um das aktuelle interpreter- und/ oder compiler environment zu erweitern.
   der compiler könnte members für alle importierten methoden generieren, oder nur einen member vom typ Object[],
   und die environmenteinträge zeigen dann mit fixen indizes in dieses array:
     statt "write" -> rt()::_write (das gilt in der form eh nur für vordef prim)
     oder  "pi" -> "_pi"
       ->  "imported-name2" -> modulname[2]
     das würd eher einfach gehen, wenn murmelprogram zwei arrays liefert: eins mit den namen, eins mit den werten. oder ein 2dim array mit name/wert tupeln.
     sollte beim importieren ein neues array mit kopien der werte gemacht werden? soll ein importierendes modul die globals des importierten moduls ändern können?
     -> wsl keine kopie, beim bisherigen load bzw. require kann auch jeder alles ändern. hiesse dann: 2 arrays, eins mit namen wird zum erzeugen der environmenteinträge verwendet,
        das andere wird mittels des neuen member referenziert.
        obiges würd für compiler funktionieren. vielleicht muss es auch zusätzlich oder stattdessen ein array mit enventries (oder eine alist?) für den interpreter geben?
        oder müssen compiler und interpreter gar nicht synchron laufen, weil eval sieht nur "predef topenv" + das was als argument mitgegeben wird?

funktionen symbol->string und string->symbol, wobei symbol->string ist symbol-name, und string->symbol ist make-symbol
und (intern symbol) -> interned-symbol
-> vielleicht doch endlich umstellen, dass der reader lc/ uc/ nix macht (mit befehlszeilenoption?), und stringvergleiche case sensitiv sind?!!!!!
   -> bei case-insensitiven stringvergleichen gäbe es potenziell gefährliche unterschiede zu CL: in CL ist (intern (make-symbol "AaA")) != aaa, in Murmel wäre das das gleiche symbol


macht ein macro with-iterator sinn (für Java iterator)?, siehe auch http://clhs.lisp.se/Body/m_w_hash.htm

safety könnte werden:
3 wie bisher alles checken
2 es kann CLassCastExceptions geben statt error
1 es kann saturating overflow geben
0 es kann wraparound overflow geben

nthcdr und nth sollten ggf. von mlib nach murmel wg. ArraySlice, und wg. Strings
-> besser (elt sequence index), http://www.lispworks.com/documentation/HyperSpec/Body/f_elt.htm

funktion die den awt frame eines turtleframe liefert, für java interop

:: könnte statt nur strings auch symbols schlucken:
-> (:: java.lang.System currentTimeMillis)
   -> nein, geht so nicht weil :: ist keine special form, der versuch, die symbols aufzulösen gibt fehler
      -> symbols wären trotzdem sinnvoll, dann könnt man ein macro basteln das quoted, und/ oder ein macro, das aus klasse, methode und einer plist mit typ/wert
         einen call bastelt (bei instanzmethoden müsste die plist wohl mit "this" <objekt> beginnen)
         oder alist statt plist? -> egal, plist ist weniger tipparbeit



dpans3 steht für "Common Lisp ANSI draft 3", das war der Input für AnsiCL
siehe https://www.reddit.com/r/lisp/comments/5xncjo/is_there_a_lispy_clhs_anywhere/ für eine diskussion re: Lizenz
TeX Sources (frei) gibts:
http://www.cs.cmu.edu/Groups//AI/lang/lisp/doc/standard/ansi/dpans/
https://github.com/xach/dpans
https://github.com/antoszka/dpANS3

Is there a straightforward lisp equivalent of Python's generators?
-> https://stackoverflow.com/questions/32956033/is-there-a-straightforward-lisp-equivalent-of-pythons-generators


letrec im compiler ist fishy, laut langref sollten folgende variablen undefined sein, sind aber null
"if (args1[0] == UNASSIGNED) {...} else argCheck(loc, 3, args1.length);" & Co brauchts nur bei named letrec? den "..." teil brauchts ohne named immer, if clause brauchts nur bei named

   JMurmel> (letrec ((a (lambda () b)) (c (a)) (b 2)) (write c))
   
   Error: eval: 'b' is not bound
   error occurred in line 1:1..1:52: (letrec ((a (lambda nil b)) (c (a)) (b 2)) (write c))
   
   JMurmel> :r
   io.github.jmurmel.LambdaJ$MurmelJavaProgram$$Lambda$111/209833425@544a2ea6
   ==> t



((lambda (exp) (apply exp "hallo")) write)
-> parameter exp ist ein builtin. das geht im interpreter und bei speed=0 im compiler, geht nicht bei speed=1 im compiler,
   weil exp wird opencoded und will 2 argumente
-> ggf. warning oder error wenn builtins als parametername verwendet werden
aber:
ggf sollten nur t und nil reserved sein, der rest der bisherigen reserved words sollten nur bei zuweisung verweigert werden (setq, define, defun, letXX dynamic),
-> lambdalist, letXX, labels könnte zulässig werden
-> SBCL: (let ((t 1)) (write t)) gibt fehler, (let ((let 1)) (write let)) geht
   -> (defun let...) geht aber nicht -> Special form is an illegal function name: LET.


Common Lisp Interface Manager
CLIM II Specification
siehe http://bauhh.dyndns.org:8000/clim-spec/index.html und https://github.com/McCLIM/McCLIM



compiler: define/defun in toplevel let/let*/letrec inkl. dynamic zulassen?
-> kein named letXX
-> wäre für let over lambda, und let over lambda simuliert ein singleton, d.h. mehrere funktionen mit gemeinsamem state
-> auch in toplevel "labels"?
-> let over lambda wird wsl dann interessant, wenn man das mit makros generiert, sonst kann man auch globales define+defun machen

geht aber auch so:
JMurmel> (progn (define init) (define inc) (define dec) (let (n) (setq init (lambda (init) (setq n init)) inc (lambda () (setq n (1+ n))) dec (lambda () (setq n (1- n))))))

==> (lambda nil (setq n (1- n)))
JMurmel> (init 5) (writeln (inc)) (writeln (inc)) (writeln (dec))




siehe zeile 5099: bei funktionen ist cddr(enventry) die liste von parametern, compiletime argcount check wär einfach
runtime check brauchts wohl trotzdem für apply und higher order functions

teilweise gibts ringlistenerkennung (cdr(a) == start), das funktioniert aber nur bei listen, wo anfang mit ende verknüpft ist,
nicht aber bei einem loop mittendrin



so kann man structs faken:
ein Object[] array wird mit konstanten (also name->0-basiertes integer) indiziert

(defstruct structname membername...) spuckt einige konstanten aus (define structname.member1 0) (define structname.member2 1) usw. und funktionen und/ oder macros zum erzeugen und zugreifen

(defstruct mystruct m1 m2 m3) ->

; constructor
(defun make-mystruct ()
  (make-array (3)))

; getter für m1
(defun mystruct-m1 (ms)
  (svref ms 0))

; getter für m2
(defun mystruct-m2 (ms)
  (svref ms 1))

; getter für m3
(defun mystruct-m3 (ms)
  (svref ms 2))

; setter für m3
(defun |(setf-mystruct-m3)| (ms val)
  (setf (svref ms 2) val))


CL scheints ähnlich zu machen: http://www.lispworks.com/documentation/lw70/CLHS/Body/m_defstr.htm
in CL kann man optional mit (:type ...) die zugrunde liegende struktur angeben, list oder vector oder sonstwas.
und mit (:include ...) kann man veranlassen, dass der neue struct einen bestehenden erweitert
mit (:initial-offset) kann man einen zugrundliegenden vector/ list mit mehreren hinter- oder übereinander liegenden structs überlagern
-> nein, nur ein struct, weil es gibt keinen "placement constructor"
   -> doch, es gehen doch mehrere: die generierten funktionen der verschiedenen structs bekommen einfach eine liste/ einen vector als parameter
CL definiert noch ein typprädikat mystruct-p (ausser man verwendet :type ohne zusätzliches :named), und copy-mystruct

wenn man :type und :named verwendet, dann wird im ersten element der list/ vector 'mystruct abgespeichert, und das kann von mystruct-p verwendet werden




(compile) könnte in etwa so gehen:

kompilierter code muss lernen, freie variablen auch im environment des interpreters zu lesen und mit setq schreiben ((re-)define müsste so eigentlich auch gehen!),
   und interpretierte funktionen aufrufen (diese interpretierten funktionen müssen aber das environment des kompilierten codes sehen, und die Murmel funktion eval
   sollte ein gscheites environment mitbekommen, damit (eval '(lambda...)) aus dem compiler heraus funktionierende closures erstellen kann 
statt toplevelFormToJava() gibts eine andere funktion, es wird nicht das bisherige MurmelProgram geschrieben,sondern anders:
-> für jede freie variable gibts ein lambda, das sucht beim ersten zugriff mit assoc im environment des interpreters, und ersetzt sich selbst durch ein lambda,
   das bei künftigen zugriffen den wert aus dem environment eintrag ausliest
   -> zum zeitpunkt des ersten zugriffs können diese freien variablen existieren oder auch nicht (nur? globale variablen/ funktionen können später dazukommen)
   -> ob diese lambdas in die generierte klasse als member emitted werden müssen oder obs anonyme lambdas sein können?
      -> zum umpatchen brauchts einen namen. könnte aber statt lambda auch instanzen einer klasse sein, die hält das symbol und erst UNDEFINED und später den wert,
         und macht assoc on demand
-> diese klasse braucht also eine referenz auf das environment des interpreters zum zeitpunkt des aufrufes, und auch eine referenz auf den interpreter selbst
-> diese klasse sollte wsl. von MurmelJavaRuntime erben, da muss man halt den interpreter reinpoken statt neu erzeugen

freie variablen suchen/ schreiben und interpreter aufrufen wär bereits jetzt ohne (compile) nützlich, für eval.
-> mit eval kann man das ganze auch testen: eval erzeugt ein interpretiertes lambda, das dann vom kompilierten code aus aufgerufen wird

später könnte damit dann ein repl mit performance (durch compile) entstehen
-> compile in kompiliertem code aufrufen scheint auch nicht schwer, damit könnte man dynamisch neue kompilierte funktionen erzeugen
   -> compile sollte wsl auch makros können?
-> dann würde wsl. auch volles macroexpand-1 im compilierten code gehen oder machbar sein. interpreter müsste iwie das aktuelle environment des compilierten codes bekommen
   -> brauchts dazu eine primitive "environment"? first-class environment wär eh nicht schlecht

umsetzung: evtl wird aus MurmelJavaCompiler eine basisklasse, und abgeleitet MurmelJavaCompiler mit murmeltojavasource/class usw wie bisher, und abgeleitet
compilecompiler mit compile(LambdaJ intp, symbol oder ConsCell code, ConsCell environment)





kompilierte programme: MurmelProgram.body() kann man nur 1x laufen lassen, ab dem zweiten aufruf kommt "duplicate define"
-> alle globals am anfang von body() auf UNASSIGNED setzen, ggf. mittels generierter init-methode
-> in lambdajbm erstmal labels statt defun


tailcallSibling0(Object fn, Object[] oldargs)
tailcallSibling1(Object fn, Object[] oldargs, Object arg)
tailcallSibling2(Object fn, Object[] oldargs, Object arg1, Object arg2)
-> arg array könnte wiederverwendet werden, würde insb. bei let loop viele allokationen einsparen
-> ähnlicher trick wäre im interpreter denkbar, derzeit wächst environment bei tailcalls (aber nur bei dynamic lambdas!)


sollte (format) auf MessageFormat basieren? {1} statt %d usw. oder iwie als alternative?
-> jedenfalls delegiert String.format eh nur zu Formatter, kamma auch gleich direkt verwenden

errorMalformed könnte als ersten parameter ein enum Error übernehmen. das enum hat name und URL, es gibt enumwerte für alle special forms inkl "named let" usw. und "compilation unit".
damit könnte errroMalformed zusatzinfo wie "see http://.../murmel-langref.md#let" ausgeben.



(with-reader-printer (string string) forms...)
-> LambdaJ.pushReaderPrinter(Object, Object)/ popReaderPrinter() umsetzen
   String öffnet eine Datei, nil ändert nix, t setzt stdin/out
-> man sollte wohl angeben können, ob appended wird
   (with-reader-printer (string string) forms...) ; für rewrite (default)
   (with-reader-printer ((string t) (string nil)) forms...) ; optionaler parameter appendp: t ist append, nil (default) ist rewrite

APPLY Forms as Places http://clhs.lisp.se/Body/05_abe.htm


"(declaim (optimize (safety...": CompilerPrimitives könnten einen ersten parameter safety bekommen, der wird abgefüllt wenn die calls generiert werden
Primitives könnten den aktuellen Wert auswerten
-> achtung: safety=0 sollten nicht die checks während dem kompilieren abdrehen

tests auf testng dataprovider umstellen
die test lispfiles auch kompiliert testen, v.a. wegen der fehlerfiles
einen unittest schreiben dass MurmelJavaProgram.getValue() alle predefined globals enthaelt
-> junit tests mit ...Test.java, testng mit Test... .java

let* dynamic ändert globals für alle threads, sollte threadlocal verwenden

vielleicht sollten CompilerPrimitive und MurmelFunction das gleiche basisinterface haben mit "int type()", CompilerPrimitive und MurmelFunction haben jeweils eine defaultimplementierung
dann brauchts in funcall(Object) kein instanceof mehr?!?
-> instanceof oder zumindest cast (inkl. checkcast) brauchts schon, weil es gibt noch Primitive und ConsCell
-> müssten wohl alle 4 das gleiche basisinterface Funcallable haben, und in funcall(Object, Object...) gibts einen cast, der bei not-a-function fehlschlägt
   -> blöd, das ist wieder ein cast. bleibt wohl nur, funcall zu vermeiden
-> obs den unterschied MurmelFunction vs. CompilerPrimitive überhaupt braucht?
   -> (interpreter-) Primitive ist anders, das hat parameter "ConsCell"



oracle-actions/setup-java` GitHub action
https://www.reddit.com/r/java/comments/tdy6lt/introducing_the_oracleactionssetupjava_github/

Dependency (security) checks mit maven:
https://github.com/jeremylong/DependencyCheck#maven-plugin


https://stackoverflow.com/questions/24487805/lambda-expression-vs-method-reference

compiler: tests für verschachtelte let dynamic
ggf. bei let dynamic als endcall zumindest warnen dass TCO nicht gemacht wird
ggf. für let dynamic statt try/finally eine restore liste basteln, und die wird irgendwie von tailcall abgearbeitet



(declaim (inline... implementieren
-> cdddr könnte inlined werden, dann würden die cdr aufrufe opencoded, und effektiv der ganze cdddr aufruf opencoded

vielleicht tagbody/go/return from/return? könnte für schnellere loops verwendet werden:
  new MurmelFunction(Object... args) {
    Object ret = null;
    label:
    do {
      try {
        forms... // return-from auf gleicher ebene macht "ret=...; break label;", verschachteltes return-from macht "throw new ReturnException(...);"
      }
      catch (GoException e)     { if (e.getLabel() == label) continue label; else throw e; }
      catch (ReturnException e) { if (e.getLabel() == label) return e.getRet(); else throw e; }
    } while (false);
    return ret;
  }.apply(NOARGS);
-> problem wird wieder sein, wenn das go/ return-from eine expression sein muss, wenns in einem if steht das als ?: geschrieben wird.
   -> java funktionen go() und returnFrom() schreiben, die haben formal einen returnvalue, machen aber nur throw



 
gesondertes flag für setq, rplaca, rplacd? --no-mut
gesondertes flag für defmacro?
backquotes, append, assoc, assq



(f 1 2 . l) könnte als flacher call verarbeitet werden: ". l" wird durch den inhalt von l ersetzt
-> kann man das kompilieren? wie?
-> müsste wohl nach (apply f (append '(1 2) l)) entzuckert werden
-> kompilieren ginge, aber eine macro expansion phase wäre wohl unmöglich,
   weil man erst nach der macroexpansion phase weiss, was die macroparameter sind.
   (apply macro...) geht aus demselben grund nicht
   -> man müsste dotted list für alle special forms inkl. makros verweigern,
      dotted list ist für application in den meisten lisps verboten, d.h. dotted list
      nur für function application zulassen wäre eine erweiterung, keine änderung
      (Murmel schluckt/ erlaubt aber stillschweigend dotted lists, behandelt sie wie proper lists)

wär hübsch für rekursiven aufruf einer varargs funktion:
(defun f (a b . c)
  (f a b . c)
-> eigentlich nicht nur für rekursive aufrufe sondern für alle aufrufe, wo eine vararg funktion ihre argumente wohinschicken will

-> im interpreter bräuchte man das wsl. nur in evlis einbauen?
-> und im compiler in funcall/tailcall zur laufzeit appenden? und in opencode!
   -> vielleicht doch besser desugar?
-> aufpassen, dass nicht (f a b) 1x argumente evaluiert und (f a . b) 2x

vielleicht müsste es auch sein:
 (f a b . l) <=> (apply f (append (list a b) l)). oder einfacher: (apply f (list* a b l))
 (f . l)     <=> (apply f l)


feature headless und ggf gui
-> nein, features sollten nicht erst zur laufzeit ermittelt werden?
   -> besser: funktion headlessp
MAVEN_OPTS=-Djava.awt.headless=true und dann turtle-funktionen in murmel-langref wieder aufdrehen?


nützliche SRFIs: 1: lists, 2: and-let*, 13: String Libraries, 14: Character-set Library, 19: Time Data Types and Procedures
SRFI 197 hat chain operator & Co, siehe https://srfi.schemers.org/srfi-197/srfi-197.html
ähnlich wie ->


https://www.reddit.com/r/scheme/comments/somz8y/tail_calls_for_native_targets/
https://github.com/edn-format/edn ist so ne art erweiterte S-expressions spec

mit Class.forName() könnte man eine Klasse mit Custom Primitives laden.
-> der bestehende customenvironment trick geht eh nur im interpreter?!? wär dann nicht mehr nötig
Class.forName() könnte auch absplitten des Compilers in eine andere Klasse ermöglichen, dann würde das verbleibende LambdaJ immer noch als single source file funktionieren

(asynclet threadpool-symbol ((sym form)...) forms)
-> die binding-forms würden asynchron in threads laufen, sym wäre ein promise, innerhalb forms würde sym ggf. blockieren
-> threadpool kann normale threads oder loom threads liefern, nil wäre irgendein defaultpool





mit -Djava.awt.headless=true gibt (make-frame) eine HeadlessException
-> ggf. eine funktion um einen frame in eine datei zu schreiben? und headlessp
   und bei headless erstellt make-frame nur linecomponent, d.h. alles geht auch headless bis auf open-frame

trace sollte das symbol tracen. in der map steht aber die adresse der funktion, die ändert sich bei load oder re-defun,
und es wird nicht mehr getraced
-> umbauen dass nicht mehr eine hashmap verwendet wird, sondern der environmententry durch eine gewrappte version ersetzt wird?
   -> das würd auch im compiler gehen
   -> wär auch für profiling denkbar

compiler: alle defuns/ defines, nicht nur toplevel
-> zähler mitlaufen lassen
   im pass1 alle gen-methoden mit zähler als suffix generieren
   im pass2 zähler erneut hochzählen und die entsprechende zuweisung generieren
   -> achtung bei macros
-> das brauchts z.b. wenn makros define enthalten
-> und/ oder makros pro toplevel form expandieren, toplevel progn auch

(re-) define im compiler
-> oder doch nicht? braucht man hauptsächlich im REPL



assert, error: https://google.github.io/styleguide/lispguide.xml?showone=Assertions_and_Conditions#Assertions_and_Conditions
function error: http://clhs.lisp.se/Body/f_error.htm
macro assert: http://clhs.lisp.se/Body/m_assert.htm

warum ist assoc in jmurmel drin?
-> assoc, rassoc in mlib jeweils mit optionalem predicate (rassoc ist reverse lookup, sucht statt im car im cdr)
-> assoc-if, rassoc-if
-> support für plists (ähnlich alists aber alist hat tupel, plist hat abwechselnd key und value in einer flachen liste plus eq statt eql),
   symbol-plist wäre optional auch möglich (und get, getf, ...). get verarbeitet symbol plist, getf verarbeitet alleinstehende plists
https://gigamonkeys.com/book/beyond-lists-other-uses-for-cons-cells.html

alte define syntax zusätzlich unterstützen:
(define ((a 1) (b 2))) ???

interlisp hat
(DEFINEQ
  (DESTRUCTIVE
    (LAMBDA  (n  m)

https://stackoverflow.com/questions/7872852/map-filter-foldr-in-drracket-scheme
https://stackoverflow.com/questions/36960124/foldr-and-foldl-in-drracket
https://srfi.schemers.org/srfi-1/srfi-1.html, https://srfi.schemers.org/srfi-1/srfi-1-reference.scm


Scheme Benchmarks:
https://ecraven.github.io/r7rs-benchmarks/


communicating sequential processes (CSP) ist im prinzip die channels von go, siehe https://en.wikipedia.org/wiki/JCSP
siehe auch https://github.com/hawkir/calispel

https://github.com/stassats/swank-gauche ist ein swank server für gauche,
kamma vielleicht einen swank server für jmurmel abkupfern?!?
siehe auch https://github.com/astine/swank-client/blob/master/swank-description.markdown

mapXX vielleicht so umbauen, dass auch dotted lists erlaubt sind?
-> oder zusätzlich mapXX*?
sollte apply eine dotted list akzeptieren?
-> oder apply*?
&+ liefert bei integer args die summe als integer mit 2s complement wraparound, auch &- &*
-> oder +&, -&, *&, ggf auch /& für div
    -> Swift hat anscheinend &+, &*, &<<, etc.



java interop:
-> siehe auch LispWorks Java FFI http://www.lispworks.com/documentation/lw70/LW/html/lw-109.htm
-> siehe https://clojure.atlassian.net/browse/CLJ-2365 und https://clojure.atlassian.net/browse/CLJ-2637
Primitive und CompilerPrimitive könnten passende Java interfaces implementieren,
  z.b. Callable, Runnable, Supplier, Consumer, Predicate, defuns und lambdas ebenso
-> vielleicht sollte Primitive, CompilerPrimitive, MurmelFunction einfach diese interfaces erweitern, und die jeweiligen Methoden sind default methoden die auf murmelcode delegieren
   Predicate.test(T) implementieren als apply(Object[0]) != null usw., wenn arity nicht stimmt (also der murmelcode will args) dann gibts eh automatisch einen rt error

parenscript (das ist eine empedded sprache CL -> Javascript) hat die funktion oder makro "chain"
(chain console (log my-list)))) -> console.log(myList)
-> eine ähnliche funktion/ special form könnte Java direkt in den generierten Code injecten

"inline java" könnte man (im compiler) in etwa so machen (interpreter könnte auch on-the-fly zeugs kompilieren)
(java (a b c) "return a + b + c;")
-> (MurmelFunction)(args) -> { /*argCheck(args.length, 3);*/ Object a = args[0]; Object b = args[1]; Object c = args[2]; return a + b + c; }
-> ggf sollten auch (optional?) typen angegeben werden, dann wird eine typumwandlung reingezwickt so wie jmethod
-> vielleicht auch (java args "return args[0]") -> (MurmelFunction)(args) -> { return args[0]; }

CL+J ist ein CFFI Binding CL nach Java: https://common-lisp.net/project/cl-plus-j/
CL+J is a JNI based interface to a Java Virtual Machine through CFFI. It targets safe, exact and complete access to Java 
from Common Lisp with as high integration as possible of the Java and CL respective runtime environments 
(especially at the condition/exception level).
CL+J uses a set of reader dispatch-macros to simplify the Java code interface. In CL+J the traditional "Hello World!" becomes:
  (#_System.out.println (jstr "Hello World!"))

j.u.l logging iwie anbinden?



https://www.reddit.com/r/ProgrammingLanguages/comments/nsktgu/i_built_a_lisp/h0uadn4/
For your error handling, implement two things:

    1 Some sort of non-local jump mechanism that allows you to "return" from arbitrary points on the stack.
    2 Have the interpreter call a designated function whenever an error occurs. As far as your interpreter is concerned,
      "error handling" just means calling the error handling function, without unwinding the stack or doing anything special.
      By #1, the error handler can "return" from the original expression that triggered the error.

With those building blocks, you can implement the equivalent of Common Lisp's condition and restart system entirely in Lisp.
If you make it possible to inspect the stack from Lisp, you also gain the ability to write a debugger in Lisp.
https://gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html



--add-feature
-> z.B. jm --add-feature test
   -> damit kann man tests per feature expressions ein/ ausschalten

im repl: rplaca, rplacd, setq veraendert die history (die aus conses besteht)
-> :r fuehrt was anderes aus als der interpreter davor

as... konsequenter einsetzen statt numberArgs wenns nur um ein arg geht

macros haben mlib nicht zur verfügung oder doch?
-> checken, ggf. entweder ändern oder dokumentieren
   -> im interpreter sehen die macros defuns, im compiler nicht, weil der compiler das interpreter-eval aufruft

ein eigener macro namespace ist schlecht: zum ueberschreiben muss man wissen, obs ein macro oder eine funktion ist
-> gibts ein macro "m" dann hat "(defun m..." keine auswirkung
-> vielleicht so lassen und defun für ein macro verbieten, so wie defun für special forms verboten ist?



http://www.ulisp.com/show?37VY hat ein einfaches objekt system
vgl. Graham, Paul "On Lisp"  Prentice-Hall, New Jersey, 1994, pp. 348-379, available online at http://www.paulgraham.com/onlisptext.html.
siehe auch http://forum.ulisp.com/t/a-simple-object-system-for-ulisp/622

; makes jmurmel crash with java.lang.StackOverflowError
(defun f names
  (if names
        (cons (car names) (f (cdr names))) ; this line should be "(cons (car names) (apply f (cdr names)))"
    nil))
-> stackoverflow ist wsl ok, sollte aber in eine Murmelfehlermeldung umgelenkt werden



cmdlineflags wos let aber nicht letXXX oder ggf named let gibt
-> --no-scheme, auch null? und ggf if abdrehen
-> dann gibts nur mehr not bound, kein undefined value


vielleicht --jar und --fatjar: --fatjar erzeugt ein jar, das auch die rt enthaelt

packages koennte man mit namenspraefixes umsetzen, und bei einer symboltabelle/ einem environment bleiben.
laesst sich dann auch sehr einfach auf Java packages/ klassennamen umlegen

compiletojar, tojava, ... sollten eigentlich in der Sprache angeboten werden
-> erst mit packages, weil dann brauchts weniger parameter

ConsCell: methoden rplaca und rplacd, jeweils fuer die subklassen geeignet umsetzen: rplacd bei zwei IntArraySlices koennte die arrays in ein groesseres hintereinanderkopieren
-> erstmal nicht in der sprache anbieten, spart aber einige casts v.a. in den tests
-> und nth und nthcdr, anschliessend caaar, cdddr, ... mit nth bzw. nthcdr implementieren
-> achtung: es koennten mehrere ArraySlices auf das selbe array zeigen.
   -> Vor naiv implementiertem rplacd: alle ArraySlices zeigen auf die gleichen daten,
      aenderung ueber ein slice ist in den anderen sichtbar
   -> nachdem ein ArraySlice das array durch ein anderes ersetzt hat: slices zeigen auf verschiedene daten,
      anderungen ueber ein slice sind NICHT mehr in anderen sichtbar-> FEHLER
   -> rplacd ist nur fuer ListConsCell umsetzbar, nicht fuer ArraySlice, rplaca wuerd wsl gehen

Den Compiler retargetable machen: methoden die Code ausspucken nach emit... umbenamsen und in eine klasse zusammenfassen, es koennte mehrere solche klassen
fuer mehrere zielsprachen geben, formsTo... bekommen so eine instanz als parameter
oder visitor pattern?


ConsCell.iterator() ueberladen: iterator(typ) liefert verschiedene iteratoren:
circular list liefert nach der ersten runde hasNext() == false
                                            fehler
dotted list liefert beim zugriff auf letztes element letztes element das element
                                                                     hasNext() == false, hasNext(true) liefert das letzte element
                                                                     fehler
sowohl mapcar wie auch maplist zulassen: der iterator liefert entweder nth(cursor++) oder nthcdr(cursor++)


trace und features refactoren:
nicht int features sondern Set<Features>
statt trace >= TRC_XXX.ordinal -> methode TraceLevel.ge(TraceLevel)

anzahl parameter duerfen begrenzt werden, auch bei varargs
-> hilft bei cdr(arg) im compiler, umsetzen, dokumentieren, global mit dem wert erfinden, vgl. http://...

funktion compile, und dem interpreter beibringen, wie kompilierte funktionen aufgerufen werden, und/ oder Primitive auf MurmelFunction umstellen
-> erst CPS im compiler umsetzen

IntArraySlice, CharArraySlice, ...
string->array koennte so ein CharArraySlice liefern, readbytes koennte ein ByteArraySlice liefern
nth und nthcdr in ConsCell rein, fuer alle subklassen geeignet umsetzen
cdddr sollte als nthcdr(3) umgesetzt werden, caaar als nth(3), caddr als car(nth(2)) usw., dann waeren die ArraySlices effizienter
readObj koennte ArraySlice liefern, wenn eine sexpression mehr als X member hat, vielleicht als pratt parser umsetzen?
-> dann gibts aber keinen platz fuer zeilennummern, also ggf einen gesonderten reader zum lesen von stdin basteln



https://github.com/phoe/cafe-latte
CL conditions
dynamic variables
tagbody go
block/return-from
restart
-> block/return-from koennte wsl mit "label: for (;;) break label;" umgesetzt werden (plus das richtige result setzen)
-> tagbody/go koennte wsl mit "label: for (;;) continue label;" umgesetzt werden
-> beides wird in Java lambdas nicht gehen, ggf. im lambda "throw ..."


zeilentabellen lisp->java mitfuehren und ins java verpacken? dann koennte ein catch im main() den stacktrace umschluesseln
-> javacode sollte mehr linefeeds bekommen
-> javaassist kann linenumbertable fuer methoden neu setzen, die enthalten sourcefile und sourcezeile
-> apache bcel wsl auch, bcel ist in java mitgepackt: com.sun.org.apache.bcel

vielleicht doch nil=null und t=Boolean.TRUE? Interpreter ggf. angleichen

refactor: alles was zum interpreter gehoert in eine neue Klasse LambdaJ.MurmelInterpreter heben
-> auf gleichem Level wie LambdaJ.MurmelJavaCompiler und LambdaJ.MurmelJavaProgram
-> dann koennten Interpreter und Program das gleiche Interface fuer getValue(), getFunction() haben
-> runtime aussen vor lassen? oder es gibt methoden die implementieren z.B. write, und getrennte wrapper fuer interpreter und kompilierte programme

im environment des compilers koennt man den typ der symbole mitfuehren, das wuerde compiletime typchecks ermoeglichen.

das main von compilierten programmen sollte am ende ggf alles abbauen. vielleicht eine methode dazu, die auch exposed ist? interpreter auch?
oder macht das der gc, wenns keine referenz auf das kompilierte programm/ den interpreter mehr gibt?

compiler:
-> irgendwie alles (lambdas, letXXX, labels, ...) in eine funktion (Object[] args, var Function next) -> Object verpacken
-> next kann ggf. von der funktion woanders hin gebogen werden (fuer continuations)
-> ohne continuations: lambda ggf. vorerst nicht aendern sondern per apply(Function, params, next) ausfuehren lassen
-> mit continuations: eine continuation ist statt normalem lambda: (Function continuation, Object[] args, var Function next) -> Object
    -> die continuation kann "continuation" in next reinstecken, dann wird "continuation" als naechstes ausgefuehrt statt "next"
-> body hat dann einen loop, der die funktionen der reihe nach aufruft, jeweils das gelieferte "next" ist die naechste funktion
-> statt var parameter koennen funktionen auch ein tupel (Object, Function) als result liefern

-> kann man eigentlich im interpreter gleich machen

Tracer bei JSR-223 nutzen.

irgendwie mit maven von Murmel nach Java uebersetzen, dann kann man einen teil einer app in murmel schreiben und fast nahtlos von Java aufrufen
-> https://stackoverflow.com/questions/2147115/generating-sources-by-running-a-projects-java-class-in-maven

anstatt letXX, cond im compiler auszuprogrammieren, kann man auch desugar programmieren, idealerweise als macroexpander
-> desugar ist macroexpand mit zus. macros fuer let-> lambda usw.
-> stattdessen kann man ggf. cons, car, cdr, +, - usw inlinen (aber erst schauen ob das was bringt)

die generierten programme koennten ein cmd arg "--repl" unterstuetzen: mit dem arg gibts nach body() kein exit() sondern repl()

JSR223 vielleicht in ein zweites jar verpacken?





tests von lis.py verpacken



Objektorientierung: records (default immutable) und "methoden" ala go (wenn eine funktion als ersten parameter einen recordtyp uebernimmt)
(defrecord mutable? symbol (extends...) symbol...) -> symbol ; eigener namespace fuer records? feldsymbols haben automatisch eigenen namespace, weil sie in einer hashtable des records drinstehen ?
(make-record mutable? recordsymbol (propertysymbol value)...) -> record
(get-record recordform propertysymbol) -> value
-> unions auch reinzwicken? z.B.
   (defrecord mutable? symbol (extends...) propertysymbol-oder-unionsymbol+(propertysymbol...)...)
   -> ohne typen fuer die properties wird das wohl zu kompiziert, und java hat auch keine unions
      ohne typen sind unions auch nicht notwendig, weil man kann einem symbol verschiedene records zuweisen

methoden, also funktionen die nur fuer einen bestimmten recordtyp zutreffen, kann man machen, muss man aber nicht

vielleicht die recordnamen in den selben namespace geben wie double, integer, string (die noch keinen haben)?




tabs im scanner richtig zaehlen
col += tabsize
col = (col / tabsize) * tabsize



koennt ma namespaces irgendwie so einfuehren:
namespace xxx biegt topenv woandershin
define schreibt nicht in topenv sondern ins package
export schreibt ins topenv
import kopiert (symbol . value) entries aus einem anderen env ins aktuelle
assoc sucht erst im aktuellen namespace, dann in topenv (wie spielt das mit den gestapelten environments zusammen?)
-> namespaces nach C oder object files waeren irgendwie C und H files bzw getrennte object files - export schreibt ins .h file
   bzw exportiert das symbol aus dem object file





neuen parser: (evtl while, for (list) umsetzen?)
program ::= stmt*

stmt ::= exp ';'

exp ::= assignment | lambda | case | block | application

assignment ::= s '=' exp
-> (define s exp)

case ::= 'case' (exp block)* 'esac'
-> (cond (exp block))

block ::= '{' stmt* '}'
-> (progn explist)

lambda ::= function(p1, p2) block   		; implicit symbol 'self' for recursion
-> (lambda (p1 p2) stmt*)

application ::= builtin | f(exp1*)			; add, sub, ..., pair, list 
-> (f explist)

(e1, e2)
-> '(e1 e2)

atomexp ::= atom
-> atom


builtin:
pair(exp1, exp2)
-> (exp1 . exp2)

list(exp1, exp2, exp3)			; list(exp*)
-> (list exp1 exp2 exp3)

add(1, 2)
-> (+ 1 2)



printSEx: if (car(list) == sQuote) print "'" + printSex(cdr(list))
der reader sollte wsl ' immer auf (quote... umsetzen, egal ob quote unterstuetzt wird oder nicht





solange es kein rplaca gibt, koennte man int, float, double und ggf kurze/ lange strings/ symbols in jeweils massgeschneiderte ConsCell stecken
-> muesste sehr hohe speichereinsparung und performanceverbesserung bringen
sollte es rplaca geben, muesste dieses logik haben, um bei typaenderung in ein neues ConsCell umzukopieren und dieses ggf. einzuhaengen
-> oder typaenderungen sind verboten
-> oder man kann optional einen typ angeben, dann ists schnell und der typ ist fix, ohne typangabe ists langsam aber der typ darf sich aendern
z.B. statt
(lambda (a b) (...))
(lambda (integer a double b) (...))
 

nach bytecode compilieren: der bytecode wird dann in einem threaded interpreter abgearbeitet
der interpreter sollte wsl direkt in eval drinstehen wg. TCO. der threaded interpreter kann
direkt cons, car, cdr, +-*/ usw. ist sonst aber sehr aehnlich dem interpreter-eval.
die threaded interpreter "methode" bekommt environment
und ein int (oder char? eher byte[]) array mit bytecode und arbeitet den bytecode ab:
char[] code; XXX env;
int ip = 0;
top:
while (ip < code.length) {
switch (code[ip++]) {
case car: extendenv(...; continue top;
case cons: extendenv(new ConsCell(...; continue top;
}





Speicherverwaltung selber machen in Java oder C:

Der Heap ist ein Array int[], 2 aufeinander folgende elemente sind ein cons
allokation ist bump allocation. ist der zaehler == array.length muss das array in ein neues groesseres array umkopiert werden
die ints werden als bitmasks interpretiert:
  die niedgristen 3 bits sind der variablen typ (d.h. 8 typen moeglich)
  intwert >> 3 ist der wert:
    pointer: ein index ins array
    symbol: ein index in die (getrennte) symboltabelle
    number: die zahl
    usw.

statt 3 bits koennten mehr oder weniger verwendet werden, wird die max anzahl cons zells groesser oder kleiner
in C koennten (muessen aber nicht) Pointer wirkliche Pointer statt indizes sein, wuerde eine indirektion sparen,
  diese muessten beim realloc des arrays (i.e. heap vergroessern) aber angepasst werden
optionales GC waer moeglich, in C und in Java, oder man laessts weg fuer kleine programme
generational heaps waeren auch moeglich, dann muesste es verschiedene pointertypen geben, jeder typ zeigt in einen anderen heap
das ergebnis einer expression koennte aus dem Heap (der auch garbage enthaelt) rausextrahiert werden, indem man wie ein GC dem root folgt,
  das ergebnis ist dann ein array das kleiner ist als der heap, also der GC komprimierte Heap

das waer alles in einer Klasse Heap { cons(); car(); cdr(); } abstrahierbar, nur die klasse kennt ConsCell
-> interface ConsCell waer moeglich. beim ArrayHeap sieht ConsCellImpl so aus:
ConsCellImpl {
    ConsCell(int n);
    Object car() { return get(n); }
    Object cdr() { return get(n+1); }
    Object get(int n) {
        int type = heap[n] & 1<<3;
        int value = heap[n] >> 3;
        switch (type) {
        case integer:
        case pointer: return new Integer(carvalue);
        case symbol: return symtab[carvalue];
        case float: // Float#intBitsToFloat benutzen, vgl NaN trick in Lox
        }
    }
    rplaca(newVal)...
    rplacd(newVal)...
}

ohne variablenzuweisungen braucht man eigentlich keinen gc und kein refcounting, einfach beim return
"alles freigeben, was nicht im returnvalue steckt" ?!?
-> so wirds wohl rust machen, plus borrow checker
-> "alles freigeben, was nicht im returnvalue steckt" ist aber nicht so leicht



einen debugger in eval einbauen? expression fuer expression? und/ oder eine special form break? :break symbol?


cadr, caddr, cadar, cddr, ... in eval verwenden und schauen, wieviel kleiner eval wird
-> solche primitiven wuerden auch Lisp programme schneller machen weil weniger assoc aufrufe
-> ein optimizer, der in define oder lambda reingezwickt wird, koennte (car (cdr o)) erkennen und durch (cadr o) ersetzen
   mit rekursivem abstieg muesste man nur current node und naechste stufe betrachten
   car/car  -> caar
   car/caar -> caaar
   car/cadr -> caadr
   car/cdr  -> cadr
   car/cdar -> cadar
   car/cddr -> caddr

   cdr/car  -> cdar
   cdr/caar -> cdaar
   cdr/cadr -> cdadr
   cdr/cdr  -> cddr
   cdr/cdar -> cddar
   cdr/cddr -> cdddr
